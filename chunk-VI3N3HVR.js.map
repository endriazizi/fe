{"version":3,"sources":["node_modules/@ionic/core/dist/esm/index-CXSTcaAW.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { d as doc } from './index-ZjP4CjeZ.js';\nimport { MENU_BACK_BUTTON_PRIORITY } from './hardware-back-button-Dhbd-23H.js';\nimport { f as printIonWarning } from './index-4DxY6_gG.js';\nimport { c as componentOnReady } from './helpers-8KSQQGQy.js';\nimport { b as getIonMode } from './ionic-global-CTSyufhF.js';\nimport { c as createAnimation } from './animation-BvhAtgca.js';\n\n/**\n * baseAnimation\n * Base class which is extended by the various types. Each\n * type will provide their own animations for open and close\n * and registers itself with Menu.\n */\nconst baseAnimation = isIos => {\n  // https://material.io/guidelines/motion/movement.html#movement-movement-in-out-of-screen-bounds\n  // https://material.io/guidelines/motion/duration-easing.html#duration-easing-natural-easing-curves\n  /**\n   * \"Apply the sharp curve to items temporarily leaving the screen that may return\n   * from the same exit point. When they return, use the deceleration curve. On mobile,\n   * this transition typically occurs over 300ms\" -- MD Motion Guide\n   */\n  return createAnimation().duration(isIos ? 400 : 300);\n};\n\n/**\n * Menu Overlay Type\n * The menu slides over the content. The content\n * itself, which is under the menu, does not move.\n */\nconst menuOverlayAnimation = menu => {\n  let closedX;\n  let openedX;\n  const width = menu.width + 8;\n  const menuAnimation = createAnimation();\n  const backdropAnimation = createAnimation();\n  if (menu.isEndSide) {\n    // right side\n    closedX = width + 'px';\n    openedX = '0px';\n  } else {\n    // left side\n    closedX = -width + 'px';\n    openedX = '0px';\n  }\n  menuAnimation.addElement(menu.menuInnerEl).fromTo('transform', `translateX(${closedX})`, `translateX(${openedX})`);\n  const mode = getIonMode(menu);\n  const isIos = mode === 'ios';\n  const opacity = isIos ? 0.2 : 0.25;\n  backdropAnimation.addElement(menu.backdropEl).fromTo('opacity', 0.01, opacity);\n  return baseAnimation(isIos).addAnimation([menuAnimation, backdropAnimation]);\n};\n\n/**\n * Menu Push Type\n * The content slides over to reveal the menu underneath.\n * The menu itself also slides over to reveal its bad self.\n */\nconst menuPushAnimation = menu => {\n  let contentOpenedX;\n  let menuClosedX;\n  const mode = getIonMode(menu);\n  const width = menu.width;\n  if (menu.isEndSide) {\n    contentOpenedX = -width + 'px';\n    menuClosedX = width + 'px';\n  } else {\n    contentOpenedX = width + 'px';\n    menuClosedX = -width + 'px';\n  }\n  const menuAnimation = createAnimation().addElement(menu.menuInnerEl).fromTo('transform', `translateX(${menuClosedX})`, 'translateX(0px)');\n  const contentAnimation = createAnimation().addElement(menu.contentEl).fromTo('transform', 'translateX(0px)', `translateX(${contentOpenedX})`);\n  const backdropAnimation = createAnimation().addElement(menu.backdropEl).fromTo('opacity', 0.01, 0.32);\n  return baseAnimation(mode === 'ios').addAnimation([menuAnimation, contentAnimation, backdropAnimation]);\n};\n\n/**\n * Menu Reveal Type\n * The content slides over to reveal the menu underneath.\n * The menu itself, which is under the content, does not move.\n */\nconst menuRevealAnimation = menu => {\n  const mode = getIonMode(menu);\n  const openedX = menu.width * (menu.isEndSide ? -1 : 1) + 'px';\n  const contentOpen = createAnimation().addElement(menu.contentEl) // REVIEW\n  .fromTo('transform', 'translateX(0px)', `translateX(${openedX})`);\n  return baseAnimation(mode === 'ios').addAnimation(contentOpen);\n};\nconst createMenuController = () => {\n  const menuAnimations = new Map();\n  const menus = [];\n  const open = async menu => {\n    const menuEl = await get(menu, true);\n    if (menuEl) {\n      return menuEl.open();\n    }\n    return false;\n  };\n  const close = async menu => {\n    const menuEl = await (menu !== undefined ? get(menu, true) : getOpen());\n    if (menuEl !== undefined) {\n      return menuEl.close();\n    }\n    return false;\n  };\n  const toggle = async menu => {\n    const menuEl = await get(menu, true);\n    if (menuEl) {\n      return menuEl.toggle();\n    }\n    return false;\n  };\n  const enable = async (shouldEnable, menu) => {\n    const menuEl = await get(menu);\n    if (menuEl) {\n      menuEl.disabled = !shouldEnable;\n    }\n    return menuEl;\n  };\n  const swipeGesture = async (shouldEnable, menu) => {\n    const menuEl = await get(menu);\n    if (menuEl) {\n      menuEl.swipeGesture = shouldEnable;\n    }\n    return menuEl;\n  };\n  const isOpen = async menu => {\n    if (menu != null) {\n      const menuEl = await get(menu);\n      // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n      return menuEl !== undefined && menuEl.isOpen();\n    } else {\n      const menuEl = await getOpen();\n      return menuEl !== undefined;\n    }\n  };\n  const isEnabled = async menu => {\n    const menuEl = await get(menu);\n    if (menuEl) {\n      return !menuEl.disabled;\n    }\n    return false;\n  };\n  /**\n   * Finds and returns the menu specified by \"menu\" if registered.\n   * @param menu - The side or ID of the desired menu\n   * @param logOnMultipleSideMenus - If true, this function will log a warning\n   * if \"menu\" is a side but multiple menus on the same side were found. Since this function\n   * is used in multiple places, we default this log to false so that the calling\n   * functions can choose whether or not it is appropriate to log this warning.\n   */\n  const get = async (menu, logOnMultipleSideMenus = false) => {\n    await waitUntilReady();\n    if (menu === 'start' || menu === 'end') {\n      // there could be more than one menu on the same side\n      // so first try to get the enabled one\n      const menuRefs = menus.filter(m => m.side === menu && !m.disabled);\n      if (menuRefs.length >= 1) {\n        if (menuRefs.length > 1 && logOnMultipleSideMenus) {\n          printIonWarning(`menuController queried for a menu on the \"${menu}\" side, but ${menuRefs.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`, menuRefs.map(m => m.el));\n        }\n        return menuRefs[0].el;\n      }\n      // didn't find a menu side that is enabled\n      // so try to get the first menu side found\n      const sideMenuRefs = menus.filter(m => m.side === menu);\n      if (sideMenuRefs.length >= 1) {\n        if (sideMenuRefs.length > 1 && logOnMultipleSideMenus) {\n          printIonWarning(`menuController queried for a menu on the \"${menu}\" side, but ${sideMenuRefs.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`, sideMenuRefs.map(m => m.el));\n        }\n        return sideMenuRefs[0].el;\n      }\n    } else if (menu != null) {\n      // the menuId was not left or right\n      // so try to get the menu by its \"id\"\n      return find(m => m.menuId === menu);\n    }\n    // return the first enabled menu\n    const menuEl = find(m => !m.disabled);\n    if (menuEl) {\n      return menuEl;\n    }\n    // get the first menu in the array, if one exists\n    return menus.length > 0 ? menus[0].el : undefined;\n  };\n  /**\n   * Get the instance of the opened menu. Returns `null` if a menu is not found.\n   */\n  const getOpen = async () => {\n    await waitUntilReady();\n    return _getOpenSync();\n  };\n  /**\n   * Get all menu instances.\n   */\n  const getMenus = async () => {\n    await waitUntilReady();\n    return getMenusSync();\n  };\n  /**\n   * Get whether or not a menu is animating. Returns `true` if any\n   * menu is currently animating.\n   */\n  const isAnimating = async () => {\n    await waitUntilReady();\n    return isAnimatingSync();\n  };\n  const registerAnimation = (name, animation) => {\n    menuAnimations.set(name, animation);\n  };\n  const _register = menu => {\n    if (menus.indexOf(menu) < 0) {\n      menus.push(menu);\n    }\n  };\n  const _unregister = menu => {\n    const index = menus.indexOf(menu);\n    if (index > -1) {\n      menus.splice(index, 1);\n    }\n  };\n  const _setOpen = async (menu, shouldOpen, animated, role) => {\n    if (isAnimatingSync()) {\n      return false;\n    }\n    if (shouldOpen) {\n      const openedMenu = await getOpen();\n      if (openedMenu && menu.el !== openedMenu) {\n        await openedMenu.setOpen(false, false);\n      }\n    }\n    return menu._setOpen(shouldOpen, animated, role);\n  };\n  const _createAnimation = (type, menuCmp) => {\n    const animationBuilder = menuAnimations.get(type); // TODO(FW-2832): type\n    if (!animationBuilder) {\n      throw new Error('animation not registered');\n    }\n    const animation = animationBuilder(menuCmp);\n    return animation;\n  };\n  const _getOpenSync = () => {\n    return find(m => m._isOpen);\n  };\n  const getMenusSync = () => {\n    return menus.map(menu => menu.el);\n  };\n  const isAnimatingSync = () => {\n    return menus.some(menu => menu.isAnimating);\n  };\n  const find = predicate => {\n    const instance = menus.find(predicate);\n    if (instance !== undefined) {\n      return instance.el;\n    }\n    return undefined;\n  };\n  const waitUntilReady = () => {\n    return Promise.all(Array.from(document.querySelectorAll('ion-menu')).map(menu => new Promise(resolve => componentOnReady(menu, resolve))));\n  };\n  registerAnimation('reveal', menuRevealAnimation);\n  registerAnimation('push', menuPushAnimation);\n  registerAnimation('overlay', menuOverlayAnimation);\n  doc === null || doc === void 0 ? void 0 : doc.addEventListener('ionBackButton', ev => {\n    const openMenu = _getOpenSync();\n    if (openMenu) {\n      ev.detail.register(MENU_BACK_BUTTON_PRIORITY, () => {\n        return openMenu.close();\n      });\n    }\n  });\n  return {\n    registerAnimation,\n    get,\n    getMenus,\n    getOpen,\n    isEnabled,\n    swipeGesture,\n    isAnimating,\n    isOpen,\n    enable,\n    toggle,\n    close,\n    open,\n    _getOpenSync,\n    _createAnimation,\n    _register,\n    _unregister,\n    _setOpen\n  };\n};\nconst menuController = /*@__PURE__*/createMenuController();\nexport { menuController as m };"],"mappings":"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","names":["baseAnimation","isIos","createAnimation","menuOverlayAnimation","menu","closedX","openedX","width","menuAnimation","backdropAnimation","getIonMode","opacity","menuPushAnimation","contentOpenedX","menuClosedX","mode","contentAnimation","menuRevealAnimation","contentOpen","createMenuController","menuAnimations","menus","open","__async","menuEl","get","close","getOpen","toggle","enable","shouldEnable","swipeGesture","isOpen","isEnabled","logOnMultipleSideMenus","waitUntilReady","menuRefs","m","printIonWarning","sideMenuRefs","find","_getOpenSync","getMenus","getMenusSync","isAnimating","isAnimatingSync","registerAnimation","name","animation","_register","_unregister","index","_setOpen","shouldOpen","animated","role","openedMenu","_createAnimation","type","menuCmp","animationBuilder","predicate","instance","resolve","componentOnReady","doc","ev","openMenu","MENU_BACK_BUTTON_PRIORITY","menuController"],"x_google_ignoreList":[0]}