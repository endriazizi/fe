{"version":3,"sources":["node_modules/@ionic/core/dist/esm/ion-refresher_2.entry.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as writeTask, r as registerInstance, c as createEvent, a as readTask, j as printIonError, h, d as Host, g as getElement, e as config } from './index-4DxY6_gG.js';\nimport { g as getTimeGivenProgression } from './cubic-bezier-hHmYLOfE.js';\nimport { I as ION_CONTENT_CLASS_SELECTOR, b as ION_CONTENT_ELEMENT_SELECTOR, p as printIonContentErrorMsg, g as getScrollElement } from './index-7UbSlv7N.js';\nimport { c as componentOnReady, t as transitionEndAsync, e as clamp, g as getElementRoot, r as raf } from './helpers-8KSQQGQy.js';\nimport { d as hapticImpact, I as ImpactStyle } from './haptic-DzAMWJuk.js';\nimport { b as getIonMode } from './ionic-global-CTSyufhF.js';\nimport { c as createAnimation } from './animation-BvhAtgca.js';\nimport { E as ENABLE_HTML_CONTENT_DEFAULT, a as sanitizeDOMString } from './config-Dx_6wPIJ.js';\nimport { h as arrowDown, i as caretBackSharp } from './index-DV3sJJW8.js';\nimport { S as SPINNERS } from './spinner-configs-D4RIp70E.js';\nimport './capacitor-CFERIeaU.js';\nimport './index-ZjP4CjeZ.js';\nconst getRefresherAnimationType = contentEl => {\n  const previousSibling = contentEl.previousElementSibling;\n  const hasHeader = previousSibling !== null && previousSibling.tagName === 'ION-HEADER';\n  return hasHeader ? 'translate' : 'scale';\n};\nconst createPullingAnimation = (type, pullingSpinner, refresherEl) => {\n  return type === 'scale' ? createScaleAnimation(pullingSpinner, refresherEl) : createTranslateAnimation(pullingSpinner, refresherEl);\n};\nconst createBaseAnimation = pullingRefresherIcon => {\n  const spinner = pullingRefresherIcon.querySelector('ion-spinner');\n  const circle = spinner.shadowRoot.querySelector('circle');\n  const spinnerArrowContainer = pullingRefresherIcon.querySelector('.spinner-arrow-container');\n  const arrowContainer = pullingRefresherIcon.querySelector('.arrow-container');\n  const arrow = arrowContainer ? arrowContainer.querySelector('ion-icon') : null;\n  const baseAnimation = createAnimation().duration(1000).easing('ease-out');\n  const spinnerArrowContainerAnimation = createAnimation().addElement(spinnerArrowContainer).keyframes([{\n    offset: 0,\n    opacity: '0.3'\n  }, {\n    offset: 0.45,\n    opacity: '0.3'\n  }, {\n    offset: 0.55,\n    opacity: '1'\n  }, {\n    offset: 1,\n    opacity: '1'\n  }]);\n  const circleInnerAnimation = createAnimation().addElement(circle).keyframes([{\n    offset: 0,\n    strokeDasharray: '1px, 200px'\n  }, {\n    offset: 0.2,\n    strokeDasharray: '1px, 200px'\n  }, {\n    offset: 0.55,\n    strokeDasharray: '100px, 200px'\n  }, {\n    offset: 1,\n    strokeDasharray: '100px, 200px'\n  }]);\n  const circleOuterAnimation = createAnimation().addElement(spinner).keyframes([{\n    offset: 0,\n    transform: 'rotate(-90deg)'\n  }, {\n    offset: 1,\n    transform: 'rotate(210deg)'\n  }]);\n  /**\n   * Only add arrow animation if present\n   * this allows users to customize the spinners\n   * without errors being thrown\n   */\n  if (arrowContainer && arrow) {\n    const arrowContainerAnimation = createAnimation().addElement(arrowContainer).keyframes([{\n      offset: 0,\n      transform: 'rotate(0deg)'\n    }, {\n      offset: 0.3,\n      transform: 'rotate(0deg)'\n    }, {\n      offset: 0.55,\n      transform: 'rotate(280deg)'\n    }, {\n      offset: 1,\n      transform: 'rotate(400deg)'\n    }]);\n    const arrowAnimation = createAnimation().addElement(arrow).keyframes([{\n      offset: 0,\n      transform: 'translateX(2px) scale(0)'\n    }, {\n      offset: 0.3,\n      transform: 'translateX(2px) scale(0)'\n    }, {\n      offset: 0.55,\n      transform: 'translateX(-1.5px) scale(1)'\n    }, {\n      offset: 1,\n      transform: 'translateX(-1.5px) scale(1)'\n    }]);\n    baseAnimation.addAnimation([arrowContainerAnimation, arrowAnimation]);\n  }\n  return baseAnimation.addAnimation([spinnerArrowContainerAnimation, circleInnerAnimation, circleOuterAnimation]);\n};\nconst createScaleAnimation = (pullingRefresherIcon, refresherEl) => {\n  /**\n   * Do not take the height of the refresher icon\n   * because at this point the DOM has not updated,\n   * so the refresher icon is still hidden with\n   * display: none.\n   * The `ion-refresher` container height\n   * is roughly the amount we need to offset\n   * the icon by when pulling down.\n   */\n  const height = refresherEl.clientHeight;\n  const spinnerAnimation = createAnimation().addElement(pullingRefresherIcon).keyframes([{\n    offset: 0,\n    transform: `scale(0) translateY(-${height}px)`\n  }, {\n    offset: 1,\n    transform: 'scale(1) translateY(100px)'\n  }]);\n  return createBaseAnimation(pullingRefresherIcon).addAnimation([spinnerAnimation]);\n};\nconst createTranslateAnimation = (pullingRefresherIcon, refresherEl) => {\n  /**\n   * Do not take the height of the refresher icon\n   * because at this point the DOM has not updated,\n   * so the refresher icon is still hidden with\n   * display: none.\n   * The `ion-refresher` container height\n   * is roughly the amount we need to offset\n   * the icon by when pulling down.\n   */\n  const height = refresherEl.clientHeight;\n  const spinnerAnimation = createAnimation().addElement(pullingRefresherIcon).keyframes([{\n    offset: 0,\n    transform: `translateY(-${height}px)`\n  }, {\n    offset: 1,\n    transform: 'translateY(100px)'\n  }]);\n  return createBaseAnimation(pullingRefresherIcon).addAnimation([spinnerAnimation]);\n};\nconst createSnapBackAnimation = pullingRefresherIcon => {\n  return createAnimation().duration(125).addElement(pullingRefresherIcon).fromTo('transform', 'translateY(var(--ion-pulling-refresher-translate, 100px))', 'translateY(0px)');\n};\n// iOS Native Refresher\n// -----------------------------\nconst setSpinnerOpacity = (spinner, opacity) => {\n  spinner.style.setProperty('opacity', opacity.toString());\n};\nconst handleScrollWhilePulling = (ticks, numTicks, pullAmount) => {\n  const max = 1;\n  writeTask(() => {\n    ticks.forEach((el, i) => {\n      /**\n       * Compute the opacity of each tick\n       * mark as a percentage of the pullAmount\n       * offset by max / numTicks so\n       * the tick marks are shown staggered.\n       */\n      const min = i * (max / numTicks);\n      const range = max - min;\n      const start = pullAmount - min;\n      const progression = clamp(0, start / range, 1);\n      el.style.setProperty('opacity', progression.toString());\n    });\n  });\n};\nconst handleScrollWhileRefreshing = (spinner, lastVelocityY) => {\n  writeTask(() => {\n    // If user pulls down quickly, the spinner should spin faster\n    spinner.style.setProperty('--refreshing-rotation-duration', lastVelocityY >= 1.0 ? '0.5s' : '2s');\n    spinner.style.setProperty('opacity', '1');\n  });\n};\nconst translateElement = (el, value, duration = 200) => {\n  if (!el) {\n    return Promise.resolve();\n  }\n  const trans = transitionEndAsync(el, duration);\n  writeTask(() => {\n    el.style.setProperty('transition', `${duration}ms all ease-out`);\n    if (value === undefined) {\n      el.style.removeProperty('transform');\n    } else {\n      el.style.setProperty('transform', `translate3d(0px, ${value}, 0px)`);\n    }\n  });\n  return trans;\n};\n// Utils\n// -----------------------------\n/**\n * In order to use the native iOS refresher the device must support rubber band scrolling.\n * As part of this, we need to exclude Desktop Safari because it has a slightly different rubber band effect that is not compatible with the native refresher in Ionic.\n *\n * We also need to be careful not to include devices that spoof their user agent.\n * For example, when using iOS emulation in Chrome the user agent will be spoofed such that\n * navigator.maxTouchPointer > 0. To work around this,\n * we check to see if the apple-pay-logo is supported as a named image which is only\n * true on Apple devices.\n *\n * We previously checked referencEl.style.webkitOverflowScrolling to explicitly check\n * for rubber band support. However, this property was removed on iPadOS and it's possible\n * that this will be removed on iOS in the future too.\n *\n */\nconst supportsRubberBandScrolling = () => {\n  return navigator.maxTouchPoints > 0 && CSS.supports('background: -webkit-named-image(apple-pay-logo-black)');\n};\nconst shouldUseNativeRefresher = async (referenceEl, mode) => {\n  const refresherContent = referenceEl.querySelector('ion-refresher-content');\n  if (!refresherContent) {\n    return Promise.resolve(false);\n  }\n  await new Promise(resolve => componentOnReady(refresherContent, resolve));\n  const pullingSpinner = referenceEl.querySelector('ion-refresher-content .refresher-pulling ion-spinner');\n  const refreshingSpinner = referenceEl.querySelector('ion-refresher-content .refresher-refreshing ion-spinner');\n  return pullingSpinner !== null && refreshingSpinner !== null && (mode === 'ios' && supportsRubberBandScrolling() || mode === 'md');\n};\nconst refresherIosCss = \"ion-refresher{top:0;display:none;position:absolute;width:100%;height:60px;pointer-events:none;z-index:-1}ion-refresher{inset-inline-start:0}ion-refresher.refresher-active{display:block}ion-refresher-content{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center;height:100%}.refresher-pulling,.refresher-refreshing{display:none;width:100%}.refresher-pulling-icon,.refresher-refreshing-icon{-webkit-transform-origin:center;transform-origin:center;-webkit-transition:200ms;transition:200ms;font-size:30px;text-align:center}:host-context([dir=rtl]) .refresher-pulling-icon,:host-context([dir=rtl]) .refresher-refreshing-icon{-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}[dir=rtl] .refresher-pulling-icon,[dir=rtl] .refresher-refreshing-icon{-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}@supports selector(:dir(rtl)){.refresher-pulling-icon:dir(rtl),.refresher-refreshing-icon:dir(rtl){-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}}.refresher-pulling-text,.refresher-refreshing-text{font-size:16px;text-align:center}ion-refresher-content .arrow-container{display:none}.refresher-pulling ion-refresher-content .refresher-pulling{display:block}.refresher-ready ion-refresher-content .refresher-pulling{display:block}.refresher-ready ion-refresher-content .refresher-pulling-icon{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.refresher-refreshing ion-refresher-content .refresher-refreshing{display:block}.refresher-cancelling ion-refresher-content .refresher-pulling{display:block}.refresher-cancelling ion-refresher-content .refresher-pulling-icon{-webkit-transform:scale(0);transform:scale(0)}.refresher-completing ion-refresher-content .refresher-refreshing{display:block}.refresher-completing ion-refresher-content .refresher-refreshing-icon{-webkit-transform:scale(0);transform:scale(0)}.refresher-native .refresher-pulling-text,.refresher-native .refresher-refreshing-text{display:none}.refresher-ios .refresher-pulling-icon,.refresher-ios .refresher-refreshing-icon{color:var(--ion-text-color, #000)}.refresher-ios .refresher-pulling-text,.refresher-ios .refresher-refreshing-text{color:var(--ion-text-color, #000)}.refresher-ios .refresher-refreshing .spinner-lines-ios line,.refresher-ios .refresher-refreshing .spinner-lines-small-ios line,.refresher-ios .refresher-refreshing .spinner-crescent circle{stroke:var(--ion-text-color, #000)}.refresher-ios .refresher-refreshing .spinner-bubbles circle,.refresher-ios .refresher-refreshing .spinner-circles circle,.refresher-ios .refresher-refreshing .spinner-dots circle{fill:var(--ion-text-color, #000)}ion-refresher.refresher-native{display:block;z-index:1}ion-refresher.refresher-native ion-spinner{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:0;margin-bottom:0}.refresher-native .refresher-refreshing ion-spinner{--refreshing-rotation-duration:2s;display:none;-webkit-animation:var(--refreshing-rotation-duration) ease-out refresher-rotate forwards;animation:var(--refreshing-rotation-duration) ease-out refresher-rotate forwards}.refresher-native .refresher-refreshing{display:none;-webkit-animation:250ms linear refresher-pop forwards;animation:250ms linear refresher-pop forwards}.refresher-native ion-spinner{width:32px;height:32px;color:var(--ion-color-step-450, var(--ion-background-color-step-450, #747577))}.refresher-native.refresher-refreshing .refresher-pulling ion-spinner,.refresher-native.refresher-completing .refresher-pulling ion-spinner{display:none}.refresher-native.refresher-refreshing .refresher-refreshing ion-spinner,.refresher-native.refresher-completing .refresher-refreshing ion-spinner{display:block}.refresher-native.refresher-pulling .refresher-pulling ion-spinner{display:block}.refresher-native.refresher-pulling .refresher-refreshing ion-spinner{display:none}.refresher-native.refresher-completing ion-refresher-content .refresher-refreshing-icon{-webkit-transform:scale(0) rotate(180deg);transform:scale(0) rotate(180deg);-webkit-transition:300ms;transition:300ms}@-webkit-keyframes refresher-pop{0%{-webkit-transform:scale(1);transform:scale(1);-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in}50%{-webkit-transform:scale(1.2);transform:scale(1.2);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes refresher-pop{0%{-webkit-transform:scale(1);transform:scale(1);-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in}50%{-webkit-transform:scale(1.2);transform:scale(1.2);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}100%{-webkit-transform:scale(1);transform:scale(1)}}@-webkit-keyframes refresher-rotate{from{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}@keyframes refresher-rotate{from{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(180deg);transform:rotate(180deg)}}\";\nconst refresherMdCss = \"ion-refresher{top:0;display:none;position:absolute;width:100%;height:60px;pointer-events:none;z-index:-1}ion-refresher{inset-inline-start:0}ion-refresher.refresher-active{display:block}ion-refresher-content{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center;height:100%}.refresher-pulling,.refresher-refreshing{display:none;width:100%}.refresher-pulling-icon,.refresher-refreshing-icon{-webkit-transform-origin:center;transform-origin:center;-webkit-transition:200ms;transition:200ms;font-size:30px;text-align:center}:host-context([dir=rtl]) .refresher-pulling-icon,:host-context([dir=rtl]) .refresher-refreshing-icon{-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}[dir=rtl] .refresher-pulling-icon,[dir=rtl] .refresher-refreshing-icon{-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}@supports selector(:dir(rtl)){.refresher-pulling-icon:dir(rtl),.refresher-refreshing-icon:dir(rtl){-webkit-transform-origin:calc(100% - center);transform-origin:calc(100% - center)}}.refresher-pulling-text,.refresher-refreshing-text{font-size:16px;text-align:center}ion-refresher-content .arrow-container{display:none}.refresher-pulling ion-refresher-content .refresher-pulling{display:block}.refresher-ready ion-refresher-content .refresher-pulling{display:block}.refresher-ready ion-refresher-content .refresher-pulling-icon{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.refresher-refreshing ion-refresher-content .refresher-refreshing{display:block}.refresher-cancelling ion-refresher-content .refresher-pulling{display:block}.refresher-cancelling ion-refresher-content .refresher-pulling-icon{-webkit-transform:scale(0);transform:scale(0)}.refresher-completing ion-refresher-content .refresher-refreshing{display:block}.refresher-completing ion-refresher-content .refresher-refreshing-icon{-webkit-transform:scale(0);transform:scale(0)}.refresher-native .refresher-pulling-text,.refresher-native .refresher-refreshing-text{display:none}.refresher-md .refresher-pulling-icon,.refresher-md .refresher-refreshing-icon{color:var(--ion-text-color, #000)}.refresher-md .refresher-pulling-text,.refresher-md .refresher-refreshing-text{color:var(--ion-text-color, #000)}.refresher-md .refresher-refreshing .spinner-lines-md line,.refresher-md .refresher-refreshing .spinner-lines-small-md line,.refresher-md .refresher-refreshing .spinner-crescent circle{stroke:var(--ion-text-color, #000)}.refresher-md .refresher-refreshing .spinner-bubbles circle,.refresher-md .refresher-refreshing .spinner-circles circle,.refresher-md .refresher-refreshing .spinner-dots circle{fill:var(--ion-text-color, #000)}ion-refresher.refresher-native{display:block;z-index:1}ion-refresher.refresher-native ion-spinner{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:0;margin-bottom:0;width:24px;height:24px;color:var(--ion-color-primary, #0054e9)}ion-refresher.refresher-native .spinner-arrow-container{display:inherit}ion-refresher.refresher-native .arrow-container{display:block;position:absolute;width:24px;height:24px}ion-refresher.refresher-native .arrow-container ion-icon{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:0;margin-bottom:0;left:0;right:0;bottom:-4px;position:absolute;color:var(--ion-color-primary, #0054e9);font-size:12px}ion-refresher.refresher-native.refresher-pulling ion-refresher-content .refresher-pulling,ion-refresher.refresher-native.refresher-ready ion-refresher-content .refresher-pulling{display:-ms-flexbox;display:flex}ion-refresher.refresher-native.refresher-refreshing ion-refresher-content .refresher-refreshing,ion-refresher.refresher-native.refresher-completing ion-refresher-content .refresher-refreshing,ion-refresher.refresher-native.refresher-cancelling ion-refresher-content .refresher-refreshing{display:-ms-flexbox;display:flex}ion-refresher.refresher-native .refresher-pulling-icon{-webkit-transform:translateY(calc(-100% - 10px));transform:translateY(calc(-100% - 10px))}ion-refresher.refresher-native .refresher-pulling-icon,ion-refresher.refresher-native .refresher-refreshing-icon{-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:0;margin-bottom:0;border-radius:100%;-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px;padding-top:8px;padding-bottom:8px;display:-ms-flexbox;display:flex;border:1px solid var(--ion-color-step-200, var(--ion-background-color-step-200, #ececec));background:var(--ion-color-step-250, var(--ion-background-color-step-250, #ffffff));-webkit-box-shadow:0px 1px 6px rgba(0, 0, 0, 0.1);box-shadow:0px 1px 6px rgba(0, 0, 0, 0.1)}\";\nconst Refresher = /*#__PURE__*/(() => {\n  let Refresher = class {\n    constructor(hostRef) {\n      registerInstance(this, hostRef);\n      this.ionRefresh = createEvent(this, \"ionRefresh\", 7);\n      this.ionPull = createEvent(this, \"ionPull\", 7);\n      this.ionStart = createEvent(this, \"ionStart\", 7);\n      this.appliedStyles = false;\n      this.didStart = false;\n      this.progress = 0;\n      this.pointerDown = false;\n      this.needsCompletion = false;\n      this.didRefresh = false;\n      this.contentFullscreen = false;\n      this.lastVelocityY = 0;\n      this.animations = [];\n      this.nativeRefresher = false;\n      /**\n       * The current state which the refresher is in. The refresher's states include:\n       *\n       * - `inactive` - The refresher is not being pulled down or refreshing and is currently hidden.\n       * - `pulling` - The user is actively pulling down the refresher, but has not reached the point yet that if the user lets go, it'll refresh.\n       * - `cancelling` - The user pulled down the refresher and let go, but did not pull down far enough to kick off the `refreshing` state. After letting go, the refresher is in the `cancelling` state while it is closing, and will go back to the `inactive` state once closed.\n       * - `ready` - The user has pulled down the refresher far enough that if they let go, it'll begin the `refreshing` state.\n       * - `refreshing` - The refresher is actively waiting on the async operation to end. Once the refresh handler calls `complete()` it will begin the `completing` state.\n       * - `completing` - The `refreshing` state has finished and the refresher is in the way of closing itself. Once closed, the refresher will go back to the `inactive` state.\n       */\n      this.state = 1 /* RefresherState.Inactive */;\n      /**\n       * The minimum distance the user must pull down until the\n       * refresher will go into the `refreshing` state.\n       * Does not apply when the refresher content uses a spinner,\n       * enabling the native refresher.\n       */\n      this.pullMin = 60;\n      /**\n       * The maximum distance of the pull until the refresher\n       * will automatically go into the `refreshing` state.\n       * Defaults to the result of `pullMin + 60`.\n       * Does not apply when  the refresher content uses a spinner,\n       * enabling the native refresher.\n       */\n      this.pullMax = this.pullMin + 60;\n      /**\n       * Time it takes to close the refresher.\n       * Does not apply when the refresher content uses a spinner,\n       * enabling the native refresher.\n       */\n      this.closeDuration = '280ms';\n      /**\n       * Time it takes the refresher to snap back to the `refreshing` state.\n       * Does not apply when the refresher content uses a spinner,\n       * enabling the native refresher.\n       */\n      this.snapbackDuration = '280ms';\n      /**\n       * How much to multiply the pull speed by. To slow the pull animation down,\n       * pass a number less than `1`. To speed up the pull, pass a number greater\n       * than `1`. The default value is `1` which is equal to the speed of the cursor.\n       * If a negative value is passed in, the factor will be `1` instead.\n       *\n       * For example: If the value passed is `1.2` and the content is dragged by\n       * `10` pixels, instead of `10` pixels the content will be pulled by `12` pixels\n       * (an increase of 20 percent). If the value passed is `0.8`, the dragged amount\n       * will be `8` pixels, less than the amount the cursor has moved.\n       *\n       * Does not apply when the refresher content uses a spinner,\n       * enabling the native refresher.\n       */\n      this.pullFactor = 1;\n      /**\n       * If `true`, the refresher will be hidden.\n       */\n      this.disabled = false;\n    }\n    disabledChanged() {\n      if (this.gesture) {\n        this.gesture.enable(!this.disabled);\n      }\n    }\n    async checkNativeRefresher() {\n      const useNativeRefresher = await shouldUseNativeRefresher(this.el, getIonMode(this));\n      if (useNativeRefresher && !this.nativeRefresher) {\n        const contentEl = this.el.closest('ion-content');\n        this.setupNativeRefresher(contentEl);\n      } else if (!useNativeRefresher) {\n        this.destroyNativeRefresher();\n      }\n    }\n    destroyNativeRefresher() {\n      if (this.scrollEl && this.scrollListenerCallback) {\n        this.scrollEl.removeEventListener('scroll', this.scrollListenerCallback);\n        this.scrollListenerCallback = undefined;\n      }\n      this.nativeRefresher = false;\n    }\n    async resetNativeRefresher(el, state) {\n      this.state = state;\n      if (getIonMode(this) === 'ios') {\n        await translateElement(el, undefined, 300);\n      } else {\n        await transitionEndAsync(this.el.querySelector('.refresher-refreshing-icon'), 200);\n      }\n      this.didRefresh = false;\n      this.needsCompletion = false;\n      this.pointerDown = false;\n      this.animations.forEach(ani => ani.destroy());\n      this.animations = [];\n      this.progress = 0;\n      this.state = 1 /* RefresherState.Inactive */;\n    }\n    async setupiOSNativeRefresher(pullingSpinner, refreshingSpinner) {\n      this.elementToTransform = this.scrollEl;\n      const ticks = pullingSpinner.shadowRoot.querySelectorAll('svg');\n      let MAX_PULL = this.scrollEl.clientHeight * 0.16;\n      const NUM_TICKS = ticks.length;\n      writeTask(() => ticks.forEach(el => el.style.setProperty('animation', 'none')));\n      this.scrollListenerCallback = () => {\n        // If pointer is not on screen or refresher is not active, ignore scroll\n        if (!this.pointerDown && this.state === 1 /* RefresherState.Inactive */) {\n          return;\n        }\n        readTask(() => {\n          // PTR should only be active when overflow scrolling at the top\n          const scrollTop = this.scrollEl.scrollTop;\n          const refresherHeight = this.el.clientHeight;\n          if (scrollTop > 0) {\n            /**\n             * If refresher is refreshing and user tries to scroll\n             * progressively fade refresher out/in\n             */\n            if (this.state === 8 /* RefresherState.Refreshing */) {\n              const ratio = clamp(0, scrollTop / (refresherHeight * 0.5), 1);\n              writeTask(() => setSpinnerOpacity(refreshingSpinner, 1 - ratio));\n              return;\n            }\n            return;\n          }\n          if (this.pointerDown) {\n            if (!this.didStart) {\n              this.didStart = true;\n              this.ionStart.emit();\n            }\n            // emit \"pulling\" on every move\n            if (this.pointerDown) {\n              this.ionPull.emit();\n            }\n          }\n          /**\n           * We want to delay the start of this gesture by ~30px\n           * when initially pulling down so the refresher does not\n           * overlap with the content. But when letting go of the\n           * gesture before the refresher completes, we want the\n           * refresher tick marks to quickly fade out.\n           */\n          const offset = this.didStart ? 30 : 0;\n          const pullAmount = this.progress = clamp(0, (Math.abs(scrollTop) - offset) / MAX_PULL, 1);\n          const shouldShowRefreshingSpinner = this.state === 8 /* RefresherState.Refreshing */ || pullAmount === 1;\n          if (shouldShowRefreshingSpinner) {\n            if (this.pointerDown) {\n              handleScrollWhileRefreshing(refreshingSpinner, this.lastVelocityY);\n            }\n            if (!this.didRefresh) {\n              this.beginRefresh();\n              this.didRefresh = true;\n              hapticImpact({\n                style: ImpactStyle.Light\n              });\n              /**\n               * Clear focus from any active element to prevent scroll jumps\n               * when the refresh completes\n               */\n              const activeElement = document.activeElement;\n              if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur) !== undefined) {\n                activeElement.blur();\n              }\n              /**\n               * Translate the content element otherwise when pointer is removed\n               * from screen the scroll content will bounce back over the refresher\n               */\n              if (!this.pointerDown) {\n                translateElement(this.elementToTransform, `${refresherHeight}px`);\n              }\n            }\n          } else {\n            this.state = 2 /* RefresherState.Pulling */;\n            handleScrollWhilePulling(ticks, NUM_TICKS, pullAmount);\n          }\n        });\n      };\n      this.scrollEl.addEventListener('scroll', this.scrollListenerCallback);\n      this.gesture = (await import('./index-CfgBF1SE.js')).createGesture({\n        el: this.scrollEl,\n        gestureName: 'refresher',\n        gesturePriority: 31,\n        direction: 'y',\n        threshold: 5,\n        onStart: () => {\n          this.pointerDown = true;\n          if (!this.didRefresh) {\n            translateElement(this.elementToTransform, '0px');\n          }\n          /**\n           * If the content had `display: none` when\n           * the refresher was initialized, its clientHeight\n           * will be 0. When the gesture starts, the content\n           * will be visible, so try to get the correct\n           * client height again. This is most common when\n           * using the refresher in an ion-menu.\n           */\n          if (MAX_PULL === 0) {\n            MAX_PULL = this.scrollEl.clientHeight * 0.16;\n          }\n        },\n        onMove: ev => {\n          this.lastVelocityY = ev.velocityY;\n        },\n        onEnd: () => {\n          this.pointerDown = false;\n          this.didStart = false;\n          if (this.needsCompletion) {\n            this.resetNativeRefresher(this.elementToTransform, 32 /* RefresherState.Completing */);\n            this.needsCompletion = false;\n          } else if (this.didRefresh) {\n            readTask(() => translateElement(this.elementToTransform, `${this.el.clientHeight}px`));\n          }\n        }\n      });\n      this.disabledChanged();\n    }\n    async setupMDNativeRefresher(contentEl, pullingSpinner, refreshingSpinner) {\n      const circle = getElementRoot(pullingSpinner).querySelector('circle');\n      const pullingRefresherIcon = this.el.querySelector('ion-refresher-content .refresher-pulling-icon');\n      const refreshingCircle = getElementRoot(refreshingSpinner).querySelector('circle');\n      if (circle !== null && refreshingCircle !== null) {\n        writeTask(() => {\n          circle.style.setProperty('animation', 'none');\n          // This lines up the animation on the refreshing spinner with the pulling spinner\n          refreshingSpinner.style.setProperty('animation-delay', '-655ms');\n          refreshingCircle.style.setProperty('animation-delay', '-655ms');\n        });\n      }\n      this.gesture = (await import('./index-CfgBF1SE.js')).createGesture({\n        el: this.scrollEl,\n        gestureName: 'refresher',\n        gesturePriority: 31,\n        direction: 'y',\n        threshold: 5,\n        canStart: () => this.state !== 8 /* RefresherState.Refreshing */ && this.state !== 32 /* RefresherState.Completing */ && this.scrollEl.scrollTop === 0,\n        onStart: ev => {\n          this.progress = 0;\n          ev.data = {\n            animation: undefined,\n            didStart: false,\n            cancelled: false\n          };\n        },\n        onMove: ev => {\n          if (ev.velocityY < 0 && this.progress === 0 && !ev.data.didStart || ev.data.cancelled) {\n            ev.data.cancelled = true;\n            return;\n          }\n          if (!ev.data.didStart) {\n            ev.data.didStart = true;\n            this.state = 2 /* RefresherState.Pulling */;\n            // When ion-refresher is being used with a custom scroll target, the overflow styles need to be applied directly instead of via a css variable\n            const {\n              scrollEl\n            } = this;\n            const overflowProperty = scrollEl.matches(ION_CONTENT_CLASS_SELECTOR) ? 'overflow' : '--overflow';\n            writeTask(() => scrollEl.style.setProperty(overflowProperty, 'hidden'));\n            const animationType = getRefresherAnimationType(contentEl);\n            const animation = createPullingAnimation(animationType, pullingRefresherIcon, this.el);\n            ev.data.animation = animation;\n            animation.progressStart(false, 0);\n            this.ionStart.emit();\n            this.animations.push(animation);\n            return;\n          }\n          // Since we are using an easing curve, slow the gesture tracking down a bit\n          this.progress = clamp(0, ev.deltaY / 180 * 0.5, 1);\n          ev.data.animation.progressStep(this.progress);\n          this.ionPull.emit();\n        },\n        onEnd: ev => {\n          if (!ev.data.didStart) {\n            return;\n          }\n          this.gesture.enable(false);\n          const {\n            scrollEl\n          } = this;\n          const overflowProperty = scrollEl.matches(ION_CONTENT_CLASS_SELECTOR) ? 'overflow' : '--overflow';\n          writeTask(() => scrollEl.style.removeProperty(overflowProperty));\n          if (this.progress <= 0.4) {\n            ev.data.animation.progressEnd(0, this.progress, 500).onFinish(() => {\n              this.animations.forEach(ani => ani.destroy());\n              this.animations = [];\n              this.gesture.enable(true);\n              this.state = 1 /* RefresherState.Inactive */;\n            });\n            return;\n          }\n          const progress = getTimeGivenProgression([0, 0], [0, 0], [1, 1], [1, 1], this.progress)[0];\n          const snapBackAnimation = createSnapBackAnimation(pullingRefresherIcon);\n          this.animations.push(snapBackAnimation);\n          writeTask(async () => {\n            pullingRefresherIcon.style.setProperty('--ion-pulling-refresher-translate', `${progress * 100}px`);\n            ev.data.animation.progressEnd();\n            await snapBackAnimation.play();\n            this.beginRefresh();\n            ev.data.animation.destroy();\n            this.gesture.enable(true);\n          });\n        }\n      });\n      this.disabledChanged();\n    }\n    async setupNativeRefresher(contentEl) {\n      if (this.scrollListenerCallback || !contentEl || this.nativeRefresher || !this.scrollEl) {\n        return;\n      }\n      /**\n       * If using non-native refresher before make sure\n       * we clean up any old CSS. This can happen when\n       * a user manually calls the refresh method in a\n       * component create callback before the native\n       * refresher is setup.\n       */\n      this.setCss(0, '', false, '');\n      this.nativeRefresher = true;\n      const pullingSpinner = this.el.querySelector('ion-refresher-content .refresher-pulling ion-spinner');\n      const refreshingSpinner = this.el.querySelector('ion-refresher-content .refresher-refreshing ion-spinner');\n      if (getIonMode(this) === 'ios') {\n        this.setupiOSNativeRefresher(pullingSpinner, refreshingSpinner);\n      } else {\n        this.setupMDNativeRefresher(contentEl, pullingSpinner, refreshingSpinner);\n      }\n    }\n    componentDidUpdate() {\n      this.checkNativeRefresher();\n    }\n    async connectedCallback() {\n      if (this.el.getAttribute('slot') !== 'fixed') {\n        printIonError('[ion-refresher] - Make sure you use: <ion-refresher slot=\"fixed\">');\n        return;\n      }\n      const contentEl = this.el.closest(ION_CONTENT_ELEMENT_SELECTOR);\n      if (!contentEl) {\n        printIonContentErrorMsg(this.el);\n        return;\n      }\n      /**\n       * Waits for the content to be ready before querying the scroll\n       * or the background content element.\n       */\n      componentOnReady(contentEl, async () => {\n        const customScrollTarget = contentEl.querySelector(ION_CONTENT_CLASS_SELECTOR);\n        /**\n         * Query the custom scroll target (if available), first. In refresher implementations,\n         * the ion-refresher element will always be a direct child of ion-content (slot=\"fixed\"). By\n         * querying the custom scroll target first and falling back to the ion-content element,\n         * the correct scroll element will be returned by the implementation.\n         */\n        this.scrollEl = await getScrollElement(customScrollTarget !== null && customScrollTarget !== void 0 ? customScrollTarget : contentEl);\n        /**\n         * Query the background content element from the host ion-content element directly.\n         */\n        this.backgroundContentEl = await contentEl.getBackgroundElement();\n        /**\n         * Check if the content element is fullscreen to apply the correct styles\n         * when the refresher is refreshing. Otherwise, the refresher will be\n         * hidden because it is positioned behind the background content element.\n         */\n        this.contentFullscreen = contentEl.fullscreen;\n        if (await shouldUseNativeRefresher(this.el, getIonMode(this))) {\n          this.setupNativeRefresher(contentEl);\n        } else {\n          this.gesture = (await import('./index-CfgBF1SE.js')).createGesture({\n            el: contentEl,\n            gestureName: 'refresher',\n            gesturePriority: 31,\n            direction: 'y',\n            threshold: 20,\n            passive: false,\n            canStart: () => this.canStart(),\n            onStart: () => this.onStart(),\n            onMove: ev => this.onMove(ev),\n            onEnd: () => this.onEnd()\n          });\n          this.disabledChanged();\n        }\n      });\n    }\n    disconnectedCallback() {\n      this.destroyNativeRefresher();\n      this.scrollEl = undefined;\n      if (this.gesture) {\n        this.gesture.destroy();\n        this.gesture = undefined;\n      }\n    }\n    /**\n     * Call `complete()` when your async operation has completed.\n     * For example, the `refreshing` state is while the app is performing\n     * an asynchronous operation, such as receiving more data from an\n     * AJAX request. Once the data has been received, you then call this\n     * method to signify that the refreshing has completed and to close\n     * the refresher. This method also changes the refresher's state from\n     * `refreshing` to `completing`.\n     */\n    async complete() {\n      if (this.nativeRefresher) {\n        this.needsCompletion = true;\n        // Do not reset scroll el until user removes pointer from screen\n        if (!this.pointerDown) {\n          raf(() => raf(() => this.resetNativeRefresher(this.elementToTransform, 32 /* RefresherState.Completing */)));\n        }\n      } else {\n        this.close(32 /* RefresherState.Completing */, '120ms');\n      }\n    }\n    /**\n     * Changes the refresher's state from `refreshing` to `cancelling`.\n     */\n    async cancel() {\n      if (this.nativeRefresher) {\n        // Do not reset scroll el until user removes pointer from screen\n        if (!this.pointerDown) {\n          raf(() => raf(() => this.resetNativeRefresher(this.elementToTransform, 16 /* RefresherState.Cancelling */)));\n        }\n      } else {\n        this.close(16 /* RefresherState.Cancelling */, '');\n      }\n    }\n    /**\n     * A number representing how far down the user has pulled.\n     * The number `0` represents the user hasn't pulled down at all. The\n     * number `1`, and anything greater than `1`, represents that the user\n     * has pulled far enough down that when they let go then the refresh will\n     * happen. If they let go and the number is less than `1`, then the\n     * refresh will not happen, and the content will return to it's original\n     * position.\n     */\n    getProgress() {\n      return Promise.resolve(this.progress);\n    }\n    canStart() {\n      if (!this.scrollEl) {\n        return false;\n      }\n      if (this.state !== 1 /* RefresherState.Inactive */) {\n        return false;\n      }\n      // if the scrollTop is greater than zero then it's\n      // not possible to pull the content down yet\n      if (this.scrollEl.scrollTop > 0) {\n        return false;\n      }\n      return true;\n    }\n    onStart() {\n      this.progress = 0;\n      this.state = 1 /* RefresherState.Inactive */;\n      this.memoizeOverflowStyle();\n      /**\n       * If the content is fullscreen, then we need to\n       * set the offset-top style on the background content\n       * element to ensure that the refresher is shown.\n       */\n      if (this.contentFullscreen && this.backgroundContentEl) {\n        this.backgroundContentEl.style.setProperty('--offset-top', '0px');\n      }\n    }\n    onMove(detail) {\n      if (!this.scrollEl) {\n        return;\n      }\n      // this method can get called like a bazillion times per second,\n      // so it's built to be as efficient as possible, and does its\n      // best to do any DOM read/writes only when absolutely necessary\n      // if multi-touch then get out immediately\n      const ev = detail.event;\n      if (ev.touches !== undefined && ev.touches.length > 1) {\n        return;\n      }\n      // do nothing if it's actively refreshing\n      // or it's in the way of closing\n      // or this was never a startY\n      if ((this.state & 56 /* RefresherState._BUSY_ */) !== 0) {\n        return;\n      }\n      const pullFactor = Number.isNaN(this.pullFactor) || this.pullFactor < 0 ? 1 : this.pullFactor;\n      const deltaY = detail.deltaY * pullFactor;\n      // don't bother if they're scrolling up\n      // and have not already started dragging\n      if (deltaY <= 0) {\n        // the current Y is higher than the starting Y\n        // so they scrolled up enough to be ignored\n        this.progress = 0;\n        this.state = 1 /* RefresherState.Inactive */;\n        if (this.appliedStyles) {\n          // reset the styles only if they were applied\n          this.setCss(0, '', false, '');\n          return;\n        }\n        return;\n      }\n      if (this.state === 1 /* RefresherState.Inactive */) {\n        // this refresh is not already actively pulling down\n        // get the content's scrollTop\n        const scrollHostScrollTop = this.scrollEl.scrollTop;\n        // if the scrollTop is greater than zero then it's\n        // not possible to pull the content down yet\n        if (scrollHostScrollTop > 0) {\n          this.progress = 0;\n          return;\n        }\n        // content scrolled all the way to the top, and dragging down\n        this.state = 2 /* RefresherState.Pulling */;\n      }\n      // prevent native scroll events\n      if (ev.cancelable) {\n        ev.preventDefault();\n      }\n      // the refresher is actively pulling at this point\n      // move the scroll element within the content element\n      this.setCss(deltaY, '0ms', true, '');\n      if (deltaY === 0) {\n        // don't continue if there's no delta yet\n        this.progress = 0;\n        return;\n      }\n      const pullMin = this.pullMin;\n      // set pull progress\n      this.progress = deltaY / pullMin;\n      // emit \"start\" if it hasn't started yet\n      if (!this.didStart) {\n        this.didStart = true;\n        this.ionStart.emit();\n      }\n      // emit \"pulling\" on every move\n      this.ionPull.emit();\n      // do nothing if the delta is less than the pull threshold\n      if (deltaY < pullMin) {\n        // ensure it stays in the pulling state, cuz its not ready yet\n        this.state = 2 /* RefresherState.Pulling */;\n        return;\n      }\n      if (deltaY > this.pullMax) {\n        // they pulled farther than the max, so kick off the refresh\n        this.beginRefresh();\n        return;\n      }\n      // pulled farther than the pull min!!\n      // it is now in the `ready` state!!\n      // if they let go then it'll refresh, kerpow!!\n      this.state = 4 /* RefresherState.Ready */;\n      return;\n    }\n    onEnd() {\n      // only run in a zone when absolutely necessary\n      if (this.state === 4 /* RefresherState.Ready */) {\n        // they pulled down far enough, so it's ready to refresh\n        this.beginRefresh();\n      } else if (this.state === 2 /* RefresherState.Pulling */) {\n        // they were pulling down, but didn't pull down far enough\n        // set the content back to it's original location\n        // and close the refresher\n        // set that the refresh is actively cancelling\n        this.cancel();\n      } else if (this.state === 1 /* RefresherState.Inactive */) {\n        /**\n         * The pull to refresh gesture was aborted\n         * so we should immediately restore any overflow styles\n         * that have been modified. Do not call this.cancel\n         * because the styles will only be reset after a timeout.\n         * If the gesture is aborted then scrolling should be\n         * available right away.\n         */\n        this.restoreOverflowStyle();\n      }\n    }\n    beginRefresh() {\n      // assumes we're already back in a zone\n      // they pulled down far enough, so it's ready to refresh\n      this.state = 8 /* RefresherState.Refreshing */;\n      // place the content in a hangout position while it thinks\n      this.setCss(this.pullMin, this.snapbackDuration, true, '');\n      /**\n       * Clear focus from any active element to prevent the browser\n       * from restoring focus and causing scroll jumps after refresh.\n       * This ensures the view stays at the top after refresh completes.\n       */\n      const activeElement = document.activeElement;\n      if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur) !== undefined) {\n        activeElement.blur();\n      }\n      // emit \"refresh\" because it was pulled down far enough\n      // and they let go to begin refreshing\n      this.ionRefresh.emit({\n        complete: this.complete.bind(this)\n      });\n    }\n    close(state, delay) {\n      // create fallback timer incase something goes wrong with transitionEnd event\n      setTimeout(() => {\n        var _a;\n        this.state = 1 /* RefresherState.Inactive */;\n        this.progress = 0;\n        this.didStart = false;\n        /**\n         * Reset any overflow styles so the\n         * user can scroll again.\n         */\n        this.setCss(0, '0ms', false, '', true);\n        /**\n         * Reset the offset-top style on the background content\n         * when the refresher is no longer refreshing and the\n         * content is fullscreen.\n         *\n         * This ensures that the behavior of background content\n         * does not change when refreshing is complete.\n         */\n        if (this.contentFullscreen && this.backgroundContentEl) {\n          (_a = this.backgroundContentEl) === null || _a === void 0 ? void 0 : _a.style.removeProperty('--offset-top');\n        }\n      }, 600);\n      // reset the styles on the scroll element\n      // set that the refresh is actively cancelling/completing\n      this.state = state;\n      this.setCss(0, this.closeDuration, true, delay);\n    }\n    setCss(y, duration, overflowVisible, delay, shouldRestoreOverflowStyle = false) {\n      if (this.nativeRefresher) {\n        return;\n      }\n      this.appliedStyles = y > 0;\n      writeTask(() => {\n        if (this.scrollEl && this.backgroundContentEl) {\n          const scrollStyle = this.scrollEl.style;\n          const backgroundStyle = this.backgroundContentEl.style;\n          scrollStyle.transform = backgroundStyle.transform = y > 0 ? `translateY(${y}px) translateZ(0px)` : '';\n          scrollStyle.transitionDuration = backgroundStyle.transitionDuration = duration;\n          scrollStyle.transitionDelay = backgroundStyle.transitionDelay = delay;\n          scrollStyle.overflow = overflowVisible ? 'hidden' : '';\n        }\n        /**\n         * Reset the overflow styles only once\n         * the pull to refresh effect has been closed.\n         * This ensures that the gesture is done\n         * and the refresh operation has either\n         * been aborted or has completed.\n         */\n        if (shouldRestoreOverflowStyle) {\n          this.restoreOverflowStyle();\n        }\n      });\n    }\n    memoizeOverflowStyle() {\n      if (this.scrollEl) {\n        const {\n          overflow,\n          overflowX,\n          overflowY\n        } = this.scrollEl.style;\n        this.overflowStyles = {\n          overflow: overflow !== null && overflow !== void 0 ? overflow : '',\n          overflowX: overflowX !== null && overflowX !== void 0 ? overflowX : '',\n          overflowY: overflowY !== null && overflowY !== void 0 ? overflowY : ''\n        };\n      }\n    }\n    restoreOverflowStyle() {\n      if (this.overflowStyles !== undefined && this.scrollEl !== undefined) {\n        const {\n          overflow,\n          overflowX,\n          overflowY\n        } = this.overflowStyles;\n        this.scrollEl.style.overflow = overflow;\n        this.scrollEl.style.overflowX = overflowX;\n        this.scrollEl.style.overflowY = overflowY;\n        this.overflowStyles = undefined;\n      }\n    }\n    render() {\n      const mode = getIonMode(this);\n      return h(Host, {\n        key: '2d1bd880877b698604542ab2d602d38b9504d975',\n        slot: \"fixed\",\n        class: {\n          [mode]: true,\n          // Used internally for styling\n          [`refresher-${mode}`]: true,\n          'refresher-native': this.nativeRefresher,\n          'refresher-active': this.state !== 1 /* RefresherState.Inactive */,\n          'refresher-pulling': this.state === 2 /* RefresherState.Pulling */,\n          'refresher-ready': this.state === 4 /* RefresherState.Ready */,\n          'refresher-refreshing': this.state === 8 /* RefresherState.Refreshing */,\n          'refresher-cancelling': this.state === 16 /* RefresherState.Cancelling */,\n          'refresher-completing': this.state === 32 /* RefresherState.Completing */\n        }\n      });\n    }\n    get el() {\n      return getElement(this);\n    }\n    static get watchers() {\n      return {\n        \"disabled\": [\"disabledChanged\"]\n      };\n    }\n  };\n  Refresher.style = {\n    ios: refresherIosCss,\n    md: refresherMdCss\n  };\n  return Refresher;\n})();\nconst RefresherContent = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.customHTMLEnabled = config.get('innerHTMLTemplatesEnabled', ENABLE_HTML_CONTENT_DEFAULT);\n  }\n  componentWillLoad() {\n    if (this.pullingIcon === undefined) {\n      /**\n       * The native iOS refresher uses a spinner instead of\n       * an icon, so we need to see if this device supports\n       * the native iOS refresher.\n       */\n      const hasRubberBandScrolling = supportsRubberBandScrolling();\n      const mode = getIonMode(this);\n      const overflowRefresher = hasRubberBandScrolling ? 'lines' : arrowDown;\n      this.pullingIcon = config.get('refreshingIcon', mode === 'ios' && hasRubberBandScrolling ? config.get('spinner', overflowRefresher) : 'circular');\n    }\n    if (this.refreshingSpinner === undefined) {\n      const mode = getIonMode(this);\n      this.refreshingSpinner = config.get('refreshingSpinner', config.get('spinner', mode === 'ios' ? 'lines' : 'circular'));\n    }\n  }\n  renderPullingText() {\n    const {\n      customHTMLEnabled,\n      pullingText\n    } = this;\n    if (customHTMLEnabled) {\n      return h(\"div\", {\n        class: \"refresher-pulling-text\",\n        innerHTML: sanitizeDOMString(pullingText)\n      });\n    }\n    return h(\"div\", {\n      class: \"refresher-pulling-text\"\n    }, pullingText);\n  }\n  renderRefreshingText() {\n    const {\n      customHTMLEnabled,\n      refreshingText\n    } = this;\n    if (customHTMLEnabled) {\n      return h(\"div\", {\n        class: \"refresher-refreshing-text\",\n        innerHTML: sanitizeDOMString(refreshingText)\n      });\n    }\n    return h(\"div\", {\n      class: \"refresher-refreshing-text\"\n    }, refreshingText);\n  }\n  render() {\n    const pullingIcon = this.pullingIcon;\n    const hasSpinner = pullingIcon != null && SPINNERS[pullingIcon] !== undefined;\n    const mode = getIonMode(this);\n    return h(Host, {\n      key: 'e235f8a9a84070ece2e2066ced234a64663bfa1d',\n      class: mode\n    }, h(\"div\", {\n      key: '9121691818ddaa35801a5f442e144ac27686cf19',\n      class: \"refresher-pulling\"\n    }, this.pullingIcon && hasSpinner && h(\"div\", {\n      key: 'c8d65d740f1575041bd3b752c789077927397fe4',\n      class: \"refresher-pulling-icon\"\n    }, h(\"div\", {\n      key: '309dd904977eaa788b09ea95b7fa4996a73bec5b',\n      class: \"spinner-arrow-container\"\n    }, h(\"ion-spinner\", {\n      key: 'a2a1480f67775d56ca7822e76be1e9f983bca2f9',\n      name: this.pullingIcon,\n      paused: true\n    }), mode === 'md' && this.pullingIcon === 'circular' && h(\"div\", {\n      key: '811d7e06d324bf4b6a18a31427a43e5177f3ae3a',\n      class: \"arrow-container\"\n    }, h(\"ion-icon\", {\n      key: '86cc48e2e8dc054ff6ff1299094da35b524be63d',\n      icon: caretBackSharp,\n      \"aria-hidden\": \"true\"\n    })))), this.pullingIcon && !hasSpinner && h(\"div\", {\n      key: '464ae097dbc95c18a2dd7dfd03f8489153dab719',\n      class: \"refresher-pulling-icon\"\n    }, h(\"ion-icon\", {\n      key: 'ed6875978b9035add562caa743a68353743d978f',\n      icon: this.pullingIcon,\n      lazy: false,\n      \"aria-hidden\": \"true\"\n    })), this.pullingText !== undefined && this.renderPullingText()), h(\"div\", {\n      key: 'aff891924e44354543fec484e5cde1ca92e69904',\n      class: \"refresher-refreshing\"\n    }, this.refreshingSpinner && h(\"div\", {\n      key: '842d7ac4ff10a1058775493d62f31cbdcd34f7a0',\n      class: \"refresher-refreshing-icon\"\n    }, h(\"ion-spinner\", {\n      key: '8c3e6195501e7e78d5cde1e3ad1fef90fd4a953f',\n      name: this.refreshingSpinner\n    })), this.refreshingText !== undefined && this.renderRefreshingText()));\n  }\n  get el() {\n    return getElement(this);\n  }\n};\nexport { Refresher as ion_refresher, RefresherContent as ion_refresher_content };"],"mappings":"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","names":["getRefresherAnimationType","contentEl","previousSibling","createPullingAnimation","type","pullingSpinner","refresherEl","createScaleAnimation","createTranslateAnimation","createBaseAnimation","pullingRefresherIcon","spinner","circle","spinnerArrowContainer","arrowContainer","arrow","baseAnimation","createAnimation","spinnerArrowContainerAnimation","circleInnerAnimation","circleOuterAnimation","arrowContainerAnimation","arrowAnimation","height","spinnerAnimation","createSnapBackAnimation","setSpinnerOpacity","opacity","handleScrollWhilePulling","ticks","numTicks","pullAmount","writeTask","el","i","min","range","start","progression","clamp","handleScrollWhileRefreshing","lastVelocityY","translateElement","value","duration","trans","transitionEndAsync","supportsRubberBandScrolling","shouldUseNativeRefresher","referenceEl","mode","__async","refresherContent","resolve","componentOnReady","refreshingSpinner","refresherIosCss","refresherMdCss","Refresher","hostRef","registerInstance","createEvent","useNativeRefresher","getIonMode","state","ani","MAX_PULL","NUM_TICKS","readTask","scrollTop","refresherHeight","ratio","offset","hapticImpact","ImpactStyle","activeElement","ev","getElementRoot","refreshingCircle","scrollEl","overflowProperty","ION_CONTENT_CLASS_SELECTOR","animationType","animation","progress","getTimeGivenProgression","snapBackAnimation","printIonError","ION_CONTENT_ELEMENT_SELECTOR","printIonContentErrorMsg","customScrollTarget","getScrollElement","raf","detail","pullFactor","deltaY","pullMin","delay","_a","y","overflowVisible","shouldRestoreOverflowStyle","scrollStyle","backgroundStyle","overflow","overflowX","overflowY","h","Host","getElement","RefresherContent","config","ENABLE_HTML_CONTENT_DEFAULT","hasRubberBandScrolling","overflowRefresher","arrowDown","customHTMLEnabled","pullingText","sanitizeDOMString","refreshingText","pullingIcon","hasSpinner","SPINNERS","caretBackSharp"],"x_google_ignoreList":[0]}