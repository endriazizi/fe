{
  "version": 3,
  "sources": ["src/app/providers/conference.service.ts"],
  "sourcesContent": ["import { HttpClient } from '@angular/common/http';\r\nimport { Injectable, inject } from '@angular/core';\r\nimport { of } from 'rxjs';\r\nimport { map } from 'rxjs/operators';\r\n\r\nimport {\r\n  ConferenceData,\r\n  Group,\r\n  ScheduleDay,\r\n  Session,\r\n  Speaker,\r\n} from '../interfaces/conference.interfaces';\r\nimport { UserService } from './user.service';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class ConferenceService {\r\n  http = inject(HttpClient);\r\n  user = inject(UserService);\r\n  data: ConferenceData | null = null;\r\n\r\n  load() {\r\n    if (this.data) {\r\n      return of(this.data);\r\n    } else {\r\n      return this.http\r\n        .get<ConferenceData>('assets/data/data.json')\r\n        .pipe(map(this.processData, this));\r\n    }\r\n  }\r\n\r\n  processData(data: ConferenceData): ConferenceData {\r\n    // just some good 'ol JS fun with objects and arrays\r\n    // build up the data by linking speakers to sessions\r\n    this.data = data;\r\n\r\n    // loop through each day in the schedule\r\n    this.data.schedule.forEach((day: ScheduleDay) => {\r\n      // loop through each timeline group in the day\r\n      day.groups.forEach((group: Group) => {\r\n        // loop through each session in the timeline group\r\n        group.sessions.forEach((session: Session) => {\r\n          session.speakers = [];\r\n          if (session.speakerNames) {\r\n            session.speakerNames.forEach((speakerName: string) => {\r\n              const speaker = this.data.speakers.find(\r\n                (s: Speaker) => s.name === speakerName\r\n              );\r\n              if (speaker) {\r\n                session.speakers.push(speaker);\r\n                speaker.sessions = speaker.sessions || [];\r\n                speaker.sessions.push(session);\r\n              }\r\n            });\r\n          }\r\n        });\r\n      });\r\n    });\r\n\r\n    return this.data;\r\n  }\r\n\r\n  getTimeline(\r\n    dayIndex: number,\r\n    queryText = '',\r\n    excludeTracks: string[] = [],\r\n    segment = 'all'\r\n  ) {\r\n    return this.load().pipe(\r\n      map((data: ConferenceData) => {\r\n        const day = data.schedule[dayIndex];\r\n        day.shownSessions = 0;\r\n\r\n        queryText = queryText.toLowerCase().replace(/,|\\.|-/g, ' ');\r\n        const queryWords = queryText\r\n          .split(' ')\r\n          .filter(w => !!w.trim().length);\r\n\r\n        day.groups.forEach((group: Group) => {\r\n          group.hide = true;\r\n\r\n          // Sort sessions within each group by start time\r\n          group.sessions.sort((a, b) => {\r\n            const timeA = new Date('1970/01/01 ' + a.timeStart).getTime();\r\n            const timeB = new Date('1970/01/01 ' + b.timeStart).getTime();\r\n            return timeA - timeB;\r\n          });\r\n\r\n          group.sessions.forEach((session: Session) => {\r\n            // check if this session should show or not\r\n            this.filterSession(session, queryWords, excludeTracks, segment);\r\n\r\n            if (!session.hide) {\r\n              // if this session is not hidden then this group should show\r\n              group.hide = false;\r\n              day.shownSessions++;\r\n            }\r\n          });\r\n        });\r\n\r\n        return day;\r\n      })\r\n    );\r\n  }\r\n\r\n  filterSession(\r\n    session: Session,\r\n    queryWords: string[],\r\n    excludeTracks: string[],\r\n    segment: string\r\n  ) {\r\n    let matchesQueryText = false;\r\n    if (queryWords.length) {\r\n      // of any query word is in the session name than it passes the query test\r\n      queryWords.forEach((queryWord: string) => {\r\n        if (session.name.toLowerCase().indexOf(queryWord) > -1) {\r\n          matchesQueryText = true;\r\n        }\r\n      });\r\n    } else {\r\n      // if there are no query words then this session passes the query test\r\n      matchesQueryText = true;\r\n    }\r\n\r\n    // if any of the sessions tracks are not in the\r\n    // exclude tracks then this session passes the track test\r\n    let matchesTracks = false;\r\n    session.tracks.forEach((trackName: string) => {\r\n      if (excludeTracks.indexOf(trackName) === -1) {\r\n        matchesTracks = true;\r\n      }\r\n    });\r\n\r\n    // if the segment is 'favorites', but session is not a user favorite\r\n    // then this session does not pass the segment test\r\n    let matchesSegment = false;\r\n    if (segment === 'favorites') {\r\n      if (this.user.hasFavorite(session.name)) {\r\n        matchesSegment = true;\r\n      }\r\n    } else {\r\n      matchesSegment = true;\r\n    }\r\n\r\n    // all tests must be true if it should not be hidden\r\n    session.hide = !(matchesQueryText && matchesTracks && matchesSegment);\r\n  }\r\n\r\n  getSpeakers() {\r\n    return this.load().pipe(map((data: ConferenceData) => data.speakers));\r\n  }\r\n\r\n  getTracks() {\r\n    return this.load().pipe(map((data: ConferenceData) => data.tracks));\r\n  }\r\n\r\n  getMap() {\r\n    return this.load().pipe(map((data: ConferenceData) => data.map));\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["ConferenceService", "constructor", "http", "inject", "HttpClient", "user", "UserService", "data", "load", "of", "get", "pipe", "map", "processData", "schedule", "forEach", "day", "groups", "group", "sessions", "session", "speakers", "speakerNames", "speakerName", "speaker", "find", "s", "name", "push", "getTimeline", "dayIndex", "queryText", "excludeTracks", "segment", "shownSessions", "toLowerCase", "replace", "queryWords", "split", "filter", "w", "trim", "length", "hide", "sort", "a", "b", "timeA", "Date", "timeStart", "getTime", "timeB", "filterSession", "matchesQueryText", "queryWord", "indexOf", "matchesTracks", "tracks", "trackName", "matchesSegment", "hasFavorite", "getSpeakers", "getTracks", "getMap", "factory", "\u0275fac", "providedIn", "_ConferenceService"]
}
