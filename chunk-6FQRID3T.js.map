{"version":3,"sources":["node_modules/@ionic/core/dist/esm/index-7UbSlv7N.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { c as componentOnReady } from './helpers-8KSQQGQy.js';\nimport { t as printRequiredElementError } from './index-4DxY6_gG.js';\nconst ION_CONTENT_TAG_NAME = 'ION-CONTENT';\nconst ION_CONTENT_ELEMENT_SELECTOR = 'ion-content';\nconst ION_CONTENT_CLASS_SELECTOR = '.ion-content-scroll-host';\n/**\n * Selector used for implementations reliant on `<ion-content>` for scroll event changes.\n *\n * Developers should use the `.ion-content-scroll-host` selector to target the element emitting\n * scroll events. With virtual scroll implementations this will be the host element for\n * the scroll viewport.\n */\nconst ION_CONTENT_SELECTOR = `${ION_CONTENT_ELEMENT_SELECTOR}, ${ION_CONTENT_CLASS_SELECTOR}`;\nconst isIonContent = el => el.tagName === ION_CONTENT_TAG_NAME;\n/**\n * Waits for the element host fully initialize before\n * returning the inner scroll element.\n *\n * For `ion-content` the scroll target will be the result\n * of the `getScrollElement` function.\n *\n * For custom implementations it will be the element host\n * or a selector within the host, if supplied through `scrollTarget`.\n */\nconst getScrollElement = async el => {\n  if (isIonContent(el)) {\n    await new Promise(resolve => componentOnReady(el, resolve));\n    return el.getScrollElement();\n  }\n  return el;\n};\n/**\n * Queries the element matching the selector for IonContent.\n * See ION_CONTENT_SELECTOR for the selector used.\n */\nconst findIonContent = el => {\n  /**\n   * First we try to query the custom scroll host selector in cases where\n   * the implementation is using an outer `ion-content` with an inner custom\n   * scroll container.\n   */\n  const customContentHost = el.querySelector(ION_CONTENT_CLASS_SELECTOR);\n  if (customContentHost) {\n    return customContentHost;\n  }\n  return el.querySelector(ION_CONTENT_SELECTOR);\n};\n/**\n * Queries the closest element matching the selector for IonContent.\n */\nconst findClosestIonContent = el => {\n  return el.closest(ION_CONTENT_SELECTOR);\n};\n/**\n * Scrolls to the top of the element. If an `ion-content` is found, it will scroll\n * using the public API `scrollToTop` with a duration.\n */\nconst scrollToTop = (el, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollToTop(durationMs);\n  }\n  return Promise.resolve(el.scrollTo({\n    top: 0,\n    left: 0,\n    behavior: 'smooth'\n  }));\n};\n/**\n * Scrolls by a specified X/Y distance in the component. If an `ion-content` is found, it will scroll\n * using the public API `scrollByPoint` with a duration.\n */\nconst scrollByPoint = (el, x, y, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollByPoint(x, y, durationMs);\n  }\n  return Promise.resolve(el.scrollBy({\n    top: y,\n    left: x,\n    behavior: durationMs > 0 ? 'smooth' : 'auto'\n  }));\n};\n/**\n * Prints an error informing developers that an implementation requires an element to be used\n * within either the `ion-content` selector or the `.ion-content-scroll-host` class.\n */\nconst printIonContentErrorMsg = el => {\n  return printRequiredElementError(el, ION_CONTENT_ELEMENT_SELECTOR);\n};\n/**\n * Several components in Ionic need to prevent scrolling\n * during a gesture (card modal, range, item sliding, etc).\n * Use this utility to account for ion-content and custom content hosts.\n */\nconst disableContentScrollY = contentEl => {\n  if (isIonContent(contentEl)) {\n    const ionContent = contentEl;\n    const initialScrollY = ionContent.scrollY;\n    ionContent.scrollY = false;\n    /**\n     * This should be passed into resetContentScrollY\n     * so that we can revert ion-content's scrollY to the\n     * correct state. For example, if scrollY = false\n     * initially, we do not want to enable scrolling\n     * when we call resetContentScrollY.\n     */\n    return initialScrollY;\n  } else {\n    contentEl.style.setProperty('overflow', 'hidden');\n    return true;\n  }\n};\nconst resetContentScrollY = (contentEl, initialScrollY) => {\n  if (isIonContent(contentEl)) {\n    contentEl.scrollY = initialScrollY;\n  } else {\n    contentEl.style.removeProperty('overflow');\n  }\n};\nexport { ION_CONTENT_CLASS_SELECTOR as I, findIonContent as a, ION_CONTENT_ELEMENT_SELECTOR as b, scrollByPoint as c, disableContentScrollY as d, findClosestIonContent as f, getScrollElement as g, isIonContent as i, printIonContentErrorMsg as p, resetContentScrollY as r, scrollToTop as s };"],"mappings":"wHAKA,IAAMA,EAAuB,cACvBC,EAA+B,cAC/BC,EAA6B,2BAQ7BC,EAAuB,GAAGF,CAA4B,KAAKC,CAA0B,GACrFE,EAAeC,GAAMA,EAAG,UAAYL,EAWpCM,EAAyBD,GAAME,EAAA,sBACnC,OAAIH,EAAaC,CAAE,GACjB,MAAM,IAAI,QAAQG,GAAWC,EAAiBJ,EAAIG,CAAO,CAAC,EACnDH,EAAG,iBAAiB,GAEtBA,CACT,GAKMK,EAAiBL,GAAM,CAM3B,IAAMM,EAAoBN,EAAG,cAAcH,CAA0B,EACrE,OAAIS,GAGGN,EAAG,cAAcF,CAAoB,CAC9C,EAIMS,EAAwBP,GACrBA,EAAG,QAAQF,CAAoB,EAMlCU,EAAc,CAACR,EAAIS,IACnBV,EAAaC,CAAE,EACDA,EACD,YAAYS,CAAU,EAEhC,QAAQ,QAAQT,EAAG,SAAS,CACjC,IAAK,EACL,KAAM,EACN,SAAU,QACZ,CAAC,CAAC,EAMEU,EAAgB,CAACV,EAAIW,EAAGC,EAAGH,IAC3BV,EAAaC,CAAE,EACDA,EACD,cAAcW,EAAGC,EAAGH,CAAU,EAExC,QAAQ,QAAQT,EAAG,SAAS,CACjC,IAAKY,EACL,KAAMD,EACN,SAAUF,EAAa,EAAI,SAAW,MACxC,CAAC,CAAC,EAMEI,EAA0Bb,GACvBc,EAA0Bd,EAAIJ,CAA4B,EAO7DmB,EAAwBC,GAAa,CACzC,GAAIjB,EAAaiB,CAAS,EAAG,CAC3B,IAAMC,EAAaD,EACbE,EAAiBD,EAAW,QAClC,OAAAA,EAAW,QAAU,GAQdC,CACT,KACE,QAAAF,EAAU,MAAM,YAAY,WAAY,QAAQ,EACzC,EAEX,EACMG,EAAsB,CAACH,EAAWE,IAAmB,CACrDnB,EAAaiB,CAAS,EACxBA,EAAU,QAAUE,EAEpBF,EAAU,MAAM,eAAe,UAAU,CAE7C","names":["ION_CONTENT_TAG_NAME","ION_CONTENT_ELEMENT_SELECTOR","ION_CONTENT_CLASS_SELECTOR","ION_CONTENT_SELECTOR","isIonContent","el","getScrollElement","__async","resolve","componentOnReady","findIonContent","customContentHost","findClosestIonContent","scrollToTop","durationMs","scrollByPoint","x","y","printIonContentErrorMsg","printRequiredElementError","disableContentScrollY","contentEl","ionContent","initialScrollY","resetContentScrollY"],"x_google_ignoreList":[0]}