{"version":3,"sources":["node_modules/@ionic/core/dist/esm/ion-input-otp.entry.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { r as registerInstance, c as createEvent, f as printIonWarning, h, F as Fragment, d as Host, g as getElement } from './index-4DxY6_gG.js';\nimport { i as inheritAriaAttributes } from './helpers-8KSQQGQy.js';\nimport { i as isRTL } from './dir-C53feagD.js';\nimport { c as createColorClasses } from './theme-DiVJyqlX.js';\nimport { b as getIonMode } from './ionic-global-CTSyufhF.js';\nconst inputOtpIosCss = \".sc-ion-input-otp-ios-h{--margin-top:0;--margin-end:0;--margin-bottom:0;--margin-start:0;--padding-top:16px;--padding-end:0;--padding-bottom:16px;--padding-start:0;--color:initial;--min-width:40px;--separator-width:8px;--separator-height:var(--separator-width);--separator-border-radius:999px;--separator-color:var(--ion-color-step-150, var(--ion-background-color-step-150, #d9d9d9));--highlight-color-focused:var(--ion-color-primary, #0054e9);--highlight-color-valid:var(--ion-color-success, #2dd55b);--highlight-color-invalid:var(--ion-color-danger, #c5000f);--highlight-color:var(--highlight-color-focused);display:block;position:relative;font-size:0.875rem}.input-otp-group.sc-ion-input-otp-ios{-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center}.native-wrapper.sc-ion-input-otp-ios{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;min-width:var(--min-width)}.native-input.sc-ion-input-otp-ios{border-radius:var(--border-radius);width:var(--width);min-width:inherit;height:var(--height);border-width:var(--border-width);border-style:solid;border-color:var(--border-color);background:var(--background);color:var(--color);font-size:inherit;text-align:center;-webkit-appearance:none;-moz-appearance:none;appearance:none}.has-focus.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios{caret-color:var(--highlight-color)}.input-otp-description.sc-ion-input-otp-ios{color:var(--ion-color-step-700, var(--ion-text-color-step-300, #4d4d4d));font-size:0.75rem;line-height:1.25rem;text-align:center}.input-otp-description-hidden.sc-ion-input-otp-ios{display:none}.input-otp-separator.sc-ion-input-otp-ios{border-radius:var(--separator-border-radius);-ms-flex-negative:0;flex-shrink:0;width:var(--separator-width);height:var(--separator-height);background:var(--separator-color)}.input-otp-size-small.sc-ion-input-otp-ios-h{--width:40px;--height:40px}.input-otp-size-small.sc-ion-input-otp-ios-h .input-otp-group.sc-ion-input-otp-ios{gap:8px}.input-otp-size-medium.sc-ion-input-otp-ios-h{--width:48px;--height:48px}.input-otp-size-large.sc-ion-input-otp-ios-h{--width:56px;--height:56px}.input-otp-size-medium.sc-ion-input-otp-ios-h .input-otp-group.sc-ion-input-otp-ios,.input-otp-size-large.sc-ion-input-otp-ios-h .input-otp-group.sc-ion-input-otp-ios{gap:12px}.input-otp-shape-round.sc-ion-input-otp-ios-h{--border-radius:16px}.input-otp-shape-soft.sc-ion-input-otp-ios-h{--border-radius:8px}.input-otp-shape-rectangular.sc-ion-input-otp-ios-h{--border-radius:0}.input-otp-fill-outline.sc-ion-input-otp-ios-h{--background:none}.input-otp-fill-solid.sc-ion-input-otp-ios-h{--border-color:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2))}.input-otp-disabled.sc-ion-input-otp-ios-h{--color:var(--ion-color-step-350, var(--ion-text-color-step-650, #a6a6a6))}.input-otp-fill-outline.input-otp-disabled.sc-ion-input-otp-ios-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--border-color:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6))}.input-otp-disabled.sc-ion-input-otp-ios-h,.input-otp-disabled.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios:disabled{cursor:not-allowed}.has-focus.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios:focus{--border-color:var(--highlight-color);outline:none}.input-otp-fill-outline.input-otp-readonly.sc-ion-input-otp-ios-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2))}.input-otp-fill-solid.input-otp-disabled.sc-ion-input-otp-ios-h,.input-otp-fill-solid.input-otp-readonly.sc-ion-input-otp-ios-h{--border-color:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6));--background:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6))}.ion-touched.ion-invalid.sc-ion-input-otp-ios-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-input-otp-ios-h{--highlight-color:var(--highlight-color-valid)}.has-focus.ion-valid.sc-ion-input-otp-ios-h,.ion-touched.ion-invalid.sc-ion-input-otp-ios-h{--border-color:var(--highlight-color)}.ion-color.sc-ion-input-otp-ios-h{--highlight-color-focused:var(--ion-color-base)}.input-otp-fill-outline.ion-color.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios:focus{border-color:rgba(var(--ion-color-base-rgb), 0.6)}.input-otp-fill-outline.ion-color.ion-invalid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.ion-invalid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-outline.ion-color.has-focus.ion-invalid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.has-focus.ion-invalid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios{border-color:var(--ion-color-danger, #c5000f)}.input-otp-fill-outline.ion-color.ion-valid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.ion-valid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-outline.ion-color.has-focus.ion-valid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.has-focus.ion-valid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios{border-color:var(--ion-color-success, #2dd55b)}.input-otp-fill-outline.input-otp-disabled.ion-color.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios{border-color:rgba(var(--ion-color-base-rgb), 0.3)}.sc-ion-input-otp-ios-h{--border-width:0.55px}.has-focus.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios:focus{--border-width:1px}.input-otp-fill-outline.sc-ion-input-otp-ios-h{--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, var(--ion-background-color-step-250, #c8c7cc))))}\";\nconst inputOtpMdCss = \".sc-ion-input-otp-md-h{--margin-top:0;--margin-end:0;--margin-bottom:0;--margin-start:0;--padding-top:16px;--padding-end:0;--padding-bottom:16px;--padding-start:0;--color:initial;--min-width:40px;--separator-width:8px;--separator-height:var(--separator-width);--separator-border-radius:999px;--separator-color:var(--ion-color-step-150, var(--ion-background-color-step-150, #d9d9d9));--highlight-color-focused:var(--ion-color-primary, #0054e9);--highlight-color-valid:var(--ion-color-success, #2dd55b);--highlight-color-invalid:var(--ion-color-danger, #c5000f);--highlight-color:var(--highlight-color-focused);display:block;position:relative;font-size:0.875rem}.input-otp-group.sc-ion-input-otp-md{-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center}.native-wrapper.sc-ion-input-otp-md{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;min-width:var(--min-width)}.native-input.sc-ion-input-otp-md{border-radius:var(--border-radius);width:var(--width);min-width:inherit;height:var(--height);border-width:var(--border-width);border-style:solid;border-color:var(--border-color);background:var(--background);color:var(--color);font-size:inherit;text-align:center;-webkit-appearance:none;-moz-appearance:none;appearance:none}.has-focus.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md{caret-color:var(--highlight-color)}.input-otp-description.sc-ion-input-otp-md{color:var(--ion-color-step-700, var(--ion-text-color-step-300, #4d4d4d));font-size:0.75rem;line-height:1.25rem;text-align:center}.input-otp-description-hidden.sc-ion-input-otp-md{display:none}.input-otp-separator.sc-ion-input-otp-md{border-radius:var(--separator-border-radius);-ms-flex-negative:0;flex-shrink:0;width:var(--separator-width);height:var(--separator-height);background:var(--separator-color)}.input-otp-size-small.sc-ion-input-otp-md-h{--width:40px;--height:40px}.input-otp-size-small.sc-ion-input-otp-md-h .input-otp-group.sc-ion-input-otp-md{gap:8px}.input-otp-size-medium.sc-ion-input-otp-md-h{--width:48px;--height:48px}.input-otp-size-large.sc-ion-input-otp-md-h{--width:56px;--height:56px}.input-otp-size-medium.sc-ion-input-otp-md-h .input-otp-group.sc-ion-input-otp-md,.input-otp-size-large.sc-ion-input-otp-md-h .input-otp-group.sc-ion-input-otp-md{gap:12px}.input-otp-shape-round.sc-ion-input-otp-md-h{--border-radius:16px}.input-otp-shape-soft.sc-ion-input-otp-md-h{--border-radius:8px}.input-otp-shape-rectangular.sc-ion-input-otp-md-h{--border-radius:0}.input-otp-fill-outline.sc-ion-input-otp-md-h{--background:none}.input-otp-fill-solid.sc-ion-input-otp-md-h{--border-color:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2))}.input-otp-disabled.sc-ion-input-otp-md-h{--color:var(--ion-color-step-350, var(--ion-text-color-step-650, #a6a6a6))}.input-otp-fill-outline.input-otp-disabled.sc-ion-input-otp-md-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--border-color:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6))}.input-otp-disabled.sc-ion-input-otp-md-h,.input-otp-disabled.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md:disabled{cursor:not-allowed}.has-focus.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md:focus{--border-color:var(--highlight-color);outline:none}.input-otp-fill-outline.input-otp-readonly.sc-ion-input-otp-md-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2))}.input-otp-fill-solid.input-otp-disabled.sc-ion-input-otp-md-h,.input-otp-fill-solid.input-otp-readonly.sc-ion-input-otp-md-h{--border-color:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6));--background:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6))}.ion-touched.ion-invalid.sc-ion-input-otp-md-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-input-otp-md-h{--highlight-color:var(--highlight-color-valid)}.has-focus.ion-valid.sc-ion-input-otp-md-h,.ion-touched.ion-invalid.sc-ion-input-otp-md-h{--border-color:var(--highlight-color)}.ion-color.sc-ion-input-otp-md-h{--highlight-color-focused:var(--ion-color-base)}.input-otp-fill-outline.ion-color.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md:focus{border-color:rgba(var(--ion-color-base-rgb), 0.6)}.input-otp-fill-outline.ion-color.ion-invalid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.ion-invalid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-outline.ion-color.has-focus.ion-invalid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.has-focus.ion-invalid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md{border-color:var(--ion-color-danger, #c5000f)}.input-otp-fill-outline.ion-color.ion-valid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.ion-valid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-outline.ion-color.has-focus.ion-valid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.has-focus.ion-valid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md{border-color:var(--ion-color-success, #2dd55b)}.input-otp-fill-outline.input-otp-disabled.ion-color.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md{border-color:rgba(var(--ion-color-base-rgb), 0.3)}.sc-ion-input-otp-md-h{--border-width:1px}.has-focus.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md:focus{--border-width:2px}.input-otp-fill-outline.sc-ion-input-otp-md-h{--border-color:var(--ion-color-step-300, var(--ion-background-color-step-300, #b3b3b3))}\";\nconst InputOTP = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.ionInput = createEvent(this, \"ionInput\", 7);\n    this.ionChange = createEvent(this, \"ionChange\", 7);\n    this.ionComplete = createEvent(this, \"ionComplete\", 7);\n    this.ionBlur = createEvent(this, \"ionBlur\", 7);\n    this.ionFocus = createEvent(this, \"ionFocus\", 7);\n    this.inheritedAttributes = {};\n    this.inputRefs = [];\n    this.inputId = `ion-input-otp-${inputIds++}`;\n    this.parsedSeparators = [];\n    /**\n     * Tracks whether the user is navigating through input boxes using keyboard navigation\n     * (arrow keys, tab) versus mouse clicks. This is used to determine the appropriate\n     * focus behavior when an input box is focused.\n     */\n    this.isKeyboardNavigation = false;\n    this.inputValues = [];\n    this.hasFocus = false;\n    this.previousInputValues = [];\n    /**\n     * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.\n     * Available options: `\"off\"`, `\"none\"`, `\"on\"`, `\"sentences\"`, `\"words\"`, `\"characters\"`.\n     */\n    this.autocapitalize = 'off';\n    /**\n     * If `true`, the user cannot interact with the input.\n     */\n    this.disabled = false;\n    /**\n     * The fill for the input boxes. If `\"solid\"` the input boxes will have a background. If\n     * `\"outline\"` the input boxes will be transparent with a border.\n     */\n    this.fill = 'outline';\n    /**\n     * The number of input boxes to display.\n     */\n    this.length = 4;\n    /**\n     * If `true`, the user cannot modify the value.\n     */\n    this.readonly = false;\n    /**\n     * The shape of the input boxes.\n     * If \"round\" they will have an increased border radius.\n     * If \"rectangular\" they will have no border radius.\n     * If \"soft\" they will have a soft border radius.\n     */\n    this.shape = 'round';\n    /**\n     * The size of the input boxes.\n     */\n    this.size = 'medium';\n    /**\n     * The type of input allowed in the input boxes.\n     */\n    this.type = 'number';\n    /**\n     * The value of the input group.\n     */\n    this.value = '';\n    /**\n     * Handles the focus behavior for the input OTP component.\n     *\n     * Focus behavior:\n     * 1. Keyboard navigation: Allow normal focus movement\n     * 2. Mouse click:\n     *    - If clicked box has value: Focus that box\n     *    - If clicked box is empty: Focus first empty box\n     *\n     * Emits the `ionFocus` event when the input group gains focus.\n     */\n    this.onFocus = index => event => {\n      var _a;\n      const {\n        inputRefs\n      } = this;\n      // Only emit ionFocus and set the focusedValue when the\n      // component first gains focus\n      if (!this.hasFocus) {\n        this.ionFocus.emit(event);\n        this.focusedValue = this.value;\n      }\n      this.hasFocus = true;\n      let finalIndex = index;\n      if (!this.isKeyboardNavigation) {\n        // If the clicked box has a value, focus it\n        // Otherwise focus the first empty box\n        const targetIndex = this.inputValues[index] ? index : this.getFirstEmptyIndex();\n        finalIndex = targetIndex === -1 ? this.length - 1 : targetIndex;\n        // Focus the target box\n        (_a = this.inputRefs[finalIndex]) === null || _a === void 0 ? void 0 : _a.focus();\n      }\n      // Update tabIndexes to match the focused box\n      inputRefs.forEach((input, i) => {\n        input.tabIndex = i === finalIndex ? 0 : -1;\n      });\n      // Reset the keyboard navigation flag\n      this.isKeyboardNavigation = false;\n    };\n    /**\n     * Handles the blur behavior for the input OTP component.\n     * Emits the `ionBlur` event when the input group loses focus.\n     */\n    this.onBlur = event => {\n      const {\n        inputRefs\n      } = this;\n      const relatedTarget = event.relatedTarget;\n      // Do not emit blur if we're moving to another input box in the same component\n      const isInternalFocus = relatedTarget != null && inputRefs.includes(relatedTarget);\n      if (!isInternalFocus) {\n        this.hasFocus = false;\n        // Reset tabIndexes when focus leaves the component\n        this.updateTabIndexes();\n        // Always emit ionBlur when focus leaves the component\n        this.ionBlur.emit(event);\n        // Only emit ionChange if the value has actually changed\n        if (this.focusedValue !== this.value) {\n          this.emitIonChange(event);\n        }\n      }\n    };\n    /**\n     * Handles keyboard navigation for the OTP component.\n     *\n     * Navigation:\n     * - Backspace: Clears current input and moves to previous box if empty\n     * - Arrow Left/Right: Moves focus between input boxes\n     * - Tab: Allows normal tab navigation between components\n     */\n    this.onKeyDown = index => event => {\n      const {\n        length\n      } = this;\n      const rtl = isRTL(this.el);\n      const input = event.target;\n      // Meta shortcuts are used to copy, paste, and select text\n      // We don't want to handle these keys here\n      const metaShortcuts = ['a', 'c', 'v', 'x', 'r', 'z', 'y'];\n      const isTextSelection = input.selectionStart !== input.selectionEnd;\n      // Return if the key is a meta shortcut or the input value\n      // text is selected and let the onPaste / onInput handler manage it\n      if (isTextSelection || (event.metaKey || event.ctrlKey) && metaShortcuts.includes(event.key.toLowerCase())) {\n        return;\n      }\n      if (event.key === 'Backspace') {\n        if (this.inputValues[index]) {\n          // Shift all values to the right of the current index left by one\n          for (let i = index; i < length - 1; i++) {\n            this.inputValues[i] = this.inputValues[i + 1];\n          }\n          // Clear the last box\n          this.inputValues[length - 1] = '';\n          // Update all inputRefs to match inputValues\n          for (let i = 0; i < length; i++) {\n            this.inputRefs[i].value = this.inputValues[i] || '';\n          }\n          this.updateValue(event);\n          event.preventDefault();\n        } else if (!this.inputValues[index] && index > 0) {\n          // If current input is empty, move to previous input\n          this.focusPrevious(index);\n        }\n      } else if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {\n        this.isKeyboardNavigation = true;\n        event.preventDefault();\n        const isLeft = event.key === 'ArrowLeft';\n        const shouldMoveNext = isLeft && rtl || !isLeft && !rtl;\n        // Only allow moving to the next input if the current has a value\n        if (shouldMoveNext) {\n          if (this.inputValues[index] && index < length - 1) {\n            this.focusNext(index);\n          }\n        } else {\n          this.focusPrevious(index);\n        }\n      } else if (event.key === 'Tab') {\n        this.isKeyboardNavigation = true;\n        // Let all tab events proceed normally\n        return;\n      }\n    };\n    /**\n     * Processes all input scenarios for each input box.\n     *\n     * This function manages:\n     * 1. Autofill handling\n     * 2. Input validation\n     * 3. Full selection replacement or typing in an empty box\n     * 4. Inserting in the middle with available space (shifting)\n     * 5. Single character replacement\n     */\n    this.onInput = index => event => {\n      var _a, _b;\n      const {\n        length,\n        validKeyPattern\n      } = this;\n      const input = event.target;\n      const value = input.value;\n      const previousValue = this.previousInputValues[index] || '';\n      // 1. Autofill handling\n      // If the length of the value increases by more than 1 from the previous\n      // value, treat this as autofill. This is to prevent the case where the\n      // user is typing a single character into an input box containing a value\n      // as that will trigger this function with a value length of 2 characters.\n      const isAutofill = value.length - previousValue.length > 1;\n      if (isAutofill) {\n        // Distribute valid characters across input boxes\n        const validChars = value.split('').filter(char => validKeyPattern.test(char)).slice(0, length);\n        // If there are no valid characters coming from the\n        // autofill, all input refs have to be cleared after the\n        // browser has finished the autofill behavior\n        if (validChars.length === 0) {\n          requestAnimationFrame(() => {\n            this.inputRefs.forEach(input => {\n              input.value = '';\n            });\n          });\n        }\n        for (let i = 0; i < length; i++) {\n          this.inputValues[i] = validChars[i] || '';\n          this.inputRefs[i].value = validChars[i] || '';\n        }\n        this.updateValue(event);\n        // Focus the first empty input box or the last input box if all boxes\n        // are filled after a small delay to ensure the input boxes have been\n        // updated before moving the focus\n        setTimeout(() => {\n          var _a;\n          const nextIndex = validChars.length < length ? validChars.length : length - 1;\n          (_a = this.inputRefs[nextIndex]) === null || _a === void 0 ? void 0 : _a.focus();\n        }, 20);\n        this.previousInputValues = [...this.inputValues];\n        return;\n      }\n      // 2. Input validation\n      // If the character entered is invalid (does not match the pattern),\n      // restore the previous value and exit\n      if (value.length > 0 && !validKeyPattern.test(value[value.length - 1])) {\n        input.value = this.inputValues[index] || '';\n        this.previousInputValues = [...this.inputValues];\n        return;\n      }\n      // 3. Full selection replacement or typing in an empty box\n      // If the user selects all text in the input box and types, or if the\n      // input box is empty, replace only this input box. If the box is empty,\n      // move to the next box, otherwise stay focused on this box.\n      const isAllSelected = input.selectionStart === 0 && input.selectionEnd === value.length;\n      const isEmpty = !this.inputValues[index];\n      if (isAllSelected || isEmpty) {\n        this.inputValues[index] = value;\n        input.value = value;\n        this.updateValue(event);\n        this.focusNext(index);\n        this.previousInputValues = [...this.inputValues];\n        return;\n      }\n      // 4. Inserting in the middle with available space (shifting)\n      // If typing in a filled input box and there are empty boxes at the end,\n      // shift all values starting at the current box to the right, and insert\n      // the new character at the current box.\n      const hasAvailableBoxAtEnd = this.inputValues[this.inputValues.length - 1] === '';\n      if (this.inputValues[index] && hasAvailableBoxAtEnd && value.length === 2) {\n        // Get the inserted character (from event or by diffing value/previousValue)\n        let newChar = event.data;\n        if (!newChar) {\n          newChar = value.split('').find((c, i) => c !== previousValue[i]) || value[value.length - 1];\n        }\n        // Validate the new character before shifting\n        if (!validKeyPattern.test(newChar)) {\n          input.value = this.inputValues[index] || '';\n          this.previousInputValues = [...this.inputValues];\n          return;\n        }\n        // Shift values right from the end to the insertion point\n        for (let i = this.inputValues.length - 1; i > index; i--) {\n          this.inputValues[i] = this.inputValues[i - 1];\n          this.inputRefs[i].value = this.inputValues[i] || '';\n        }\n        this.inputValues[index] = newChar;\n        this.inputRefs[index].value = newChar;\n        this.updateValue(event);\n        this.previousInputValues = [...this.inputValues];\n        return;\n      }\n      // 5. Single character replacement\n      // Handles replacing a single character in a box containing a value based\n      // on the cursor position. We need the cursor position to determine which\n      // character was the last character typed. For example, if the user types \"2\"\n      // in an input box with the cursor at the beginning of the value of \"6\",\n      // the value will be \"26\", but we want to grab the \"2\" as the last character\n      // typed.\n      const cursorPos = (_a = input.selectionStart) !== null && _a !== void 0 ? _a : value.length;\n      const newCharIndex = cursorPos - 1;\n      const newChar = (_b = value[newCharIndex]) !== null && _b !== void 0 ? _b : value[0];\n      // Check if the new character is valid before updating the value\n      if (!validKeyPattern.test(newChar)) {\n        input.value = this.inputValues[index] || '';\n        this.previousInputValues = [...this.inputValues];\n        return;\n      }\n      this.inputValues[index] = newChar;\n      input.value = newChar;\n      this.updateValue(event);\n      this.previousInputValues = [...this.inputValues];\n    };\n    /**\n     * Handles pasting text into the input OTP component.\n     * This function prevents the default paste behavior and\n     * validates the pasted text against the allowed pattern.\n     * It then updates the value of the input group and focuses\n     * the next empty input after pasting.\n     */\n    this.onPaste = event => {\n      var _a, _b;\n      const {\n        inputRefs,\n        length,\n        validKeyPattern\n      } = this;\n      event.preventDefault();\n      const pastedText = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text');\n      // If there is no pasted text, still emit the input change event\n      // because this is how the native input element behaves\n      // but return early because there is nothing to paste.\n      if (!pastedText) {\n        this.emitIonInput(event);\n        return;\n      }\n      const validChars = pastedText.split('').filter(char => validKeyPattern.test(char)).slice(0, length);\n      // Always paste starting at the first box\n      validChars.forEach((char, index) => {\n        if (index < length) {\n          this.inputRefs[index].value = char;\n          this.inputValues[index] = char;\n        }\n      });\n      // Update the value so that all input boxes are updated\n      this.value = validChars.join('');\n      this.updateValue(event);\n      // Focus the next empty input after pasting\n      // If all boxes are filled, focus the last input\n      const nextEmptyIndex = validChars.length < length ? validChars.length : length - 1;\n      (_b = inputRefs[nextEmptyIndex]) === null || _b === void 0 ? void 0 : _b.focus();\n    };\n  }\n  /**\n   * Sets focus to an input box.\n   * @param index - The index of the input box to focus (0-based).\n   * If provided and the input box has a value, the input box at that index will be focused.\n   * Otherwise, the first empty input box or the last input if all are filled will be focused.\n   */\n  async setFocus(index) {\n    var _a, _b;\n    if (typeof index === 'number') {\n      const validIndex = Math.max(0, Math.min(index, this.length - 1));\n      (_a = this.inputRefs[validIndex]) === null || _a === void 0 ? void 0 : _a.focus();\n    } else {\n      const tabbableIndex = this.getTabbableIndex();\n      (_b = this.inputRefs[tabbableIndex]) === null || _b === void 0 ? void 0 : _b.focus();\n    }\n  }\n  valueChanged() {\n    this.initializeValues();\n    this.updateTabIndexes();\n  }\n  /**\n   * Processes the separators prop into an array of numbers.\n   *\n   * If the separators prop is not provided, returns an empty array.\n   * If the separators prop is 'all', returns an array of all valid positions (1 to length-1).\n   * If the separators prop is an array, returns it as is.\n   * If the separators prop is a string, splits it by commas and parses each part as a number.\n   *\n   * If the separators are greater than the input length, it will warn and ignore the separators.\n   */\n  processSeparators() {\n    const {\n      separators,\n      length\n    } = this;\n    if (separators === undefined) {\n      this.parsedSeparators = [];\n      return;\n    }\n    if (typeof separators === 'string' && separators !== 'all') {\n      const isValidFormat = /^(\\d+)(,\\d+)*$/.test(separators);\n      if (!isValidFormat) {\n        printIonWarning(`[ion-input-otp] - Invalid separators format. Expected a comma-separated list of numbers, an array of numbers, or \"all\". Received: ${separators}`, this.el);\n        this.parsedSeparators = [];\n        return;\n      }\n    }\n    let separatorValues;\n    if (separators === 'all') {\n      separatorValues = Array.from({\n        length: length - 1\n      }, (_, i) => i + 1);\n    } else if (Array.isArray(separators)) {\n      separatorValues = separators;\n    } else {\n      separatorValues = separators.split(',').map(pos => parseInt(pos, 10)).filter(pos => !isNaN(pos));\n    }\n    // Check for duplicate separator positions\n    const duplicates = separatorValues.filter((pos, index) => separatorValues.indexOf(pos) !== index);\n    if (duplicates.length > 0) {\n      printIonWarning(`[ion-input-otp] - Duplicate separator positions are not allowed. Received: ${separators}`, this.el);\n    }\n    const invalidSeparators = separatorValues.filter(pos => pos > length);\n    if (invalidSeparators.length > 0) {\n      printIonWarning(`[ion-input-otp] - The following separator positions are greater than the input length (${length}): ${invalidSeparators.join(', ')}. These separators will be ignored.`, this.el);\n    }\n    this.parsedSeparators = separatorValues.filter(pos => pos <= length);\n  }\n  componentWillLoad() {\n    this.inheritedAttributes = inheritAriaAttributes(this.el);\n    this.processSeparators();\n    this.initializeValues();\n  }\n  componentDidLoad() {\n    this.updateTabIndexes();\n  }\n  /**\n   * Get the regex pattern for allowed characters.\n   * If a pattern is provided, use it to create a regex pattern\n   * Otherwise, use the default regex pattern based on type\n   */\n  get validKeyPattern() {\n    return new RegExp(`^${this.getPattern()}$`, 'u');\n  }\n  /**\n   * Gets the string pattern to pass to the input element\n   * and use in the regex for allowed characters.\n   */\n  getPattern() {\n    const {\n      pattern,\n      type\n    } = this;\n    if (pattern) {\n      return pattern;\n    }\n    return type === 'number' ? '[\\\\p{N}]' : '[\\\\p{L}\\\\p{N}]';\n  }\n  /**\n   * Get the default value for inputmode.\n   * If inputmode is provided, use it.\n   * Otherwise, use the default inputmode based on type\n   */\n  getInputmode() {\n    const {\n      inputmode\n    } = this;\n    if (inputmode) {\n      return inputmode;\n    }\n    if (this.type == 'number') {\n      return 'numeric';\n    } else {\n      return 'text';\n    }\n  }\n  /**\n   * Initializes the input values array based on the current value prop.\n   * This splits the value into individual characters and validates them against\n   * the allowed pattern. The values are then used as the values in the native\n   * input boxes and the value of the input group is updated.\n   */\n  initializeValues() {\n    // Clear all input values\n    this.inputValues = Array(this.length).fill('');\n    // If the value is null, undefined, or an empty string, return\n    if (this.value == null || String(this.value).length === 0) {\n      return;\n    }\n    // Split the value into individual characters and validate\n    // them against the allowed pattern\n    const chars = String(this.value).split('').slice(0, this.length);\n    chars.forEach((char, index) => {\n      if (this.validKeyPattern.test(char)) {\n        this.inputValues[index] = char;\n      }\n    });\n    // Update the value without emitting events\n    this.value = this.inputValues.join('');\n    this.previousInputValues = [...this.inputValues];\n  }\n  /**\n   * Updates the value of the input group.\n   * This updates the value of the input group and emits an `ionChange` event.\n   * If all of the input boxes are filled, it emits an `ionComplete` event.\n   */\n  updateValue(event) {\n    const {\n      inputValues,\n      length\n    } = this;\n    const newValue = inputValues.join('');\n    this.value = newValue;\n    this.emitIonInput(event);\n    if (newValue.length === length) {\n      this.ionComplete.emit({\n        value: newValue\n      });\n    }\n  }\n  /**\n   * Emits an `ionChange` event.\n   * This API should be called for user committed changes.\n   * This API should not be used for external value changes.\n   */\n  emitIonChange(event) {\n    const {\n      value\n    } = this;\n    // Checks for both null and undefined values\n    const newValue = value == null ? value : value.toString();\n    this.ionChange.emit({\n      value: newValue,\n      event\n    });\n  }\n  /**\n   * Emits an `ionInput` event.\n   * This is used to emit the input value when the user types,\n   * backspaces, or pastes.\n   */\n  emitIonInput(event) {\n    const {\n      value\n    } = this;\n    // Checks for both null and undefined values\n    const newValue = value == null ? value : value.toString();\n    this.ionInput.emit({\n      value: newValue,\n      event\n    });\n  }\n  /**\n   * Focuses the next input box.\n   */\n  focusNext(currentIndex) {\n    var _a;\n    const {\n      inputRefs,\n      length\n    } = this;\n    if (currentIndex < length - 1) {\n      (_a = inputRefs[currentIndex + 1]) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n  }\n  /**\n   * Focuses the previous input box.\n   */\n  focusPrevious(currentIndex) {\n    var _a;\n    const {\n      inputRefs\n    } = this;\n    if (currentIndex > 0) {\n      (_a = inputRefs[currentIndex - 1]) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n  }\n  /**\n   * Searches through the input values and returns the index\n   * of the first empty input.\n   * Returns -1 if all inputs are filled.\n   */\n  getFirstEmptyIndex() {\n    var _a;\n    const {\n      inputValues,\n      length\n    } = this;\n    // Create an array of the same length as the input OTP\n    // and fill it with the input values\n    const values = Array.from({\n      length\n    }, (_, i) => inputValues[i] || '');\n    return (_a = values.findIndex(value => !value || value === '')) !== null && _a !== void 0 ? _a : -1;\n  }\n  /**\n   * Returns the index of the input that should be tabbed to.\n   * If all inputs are filled, returns the last input's index.\n   * Otherwise, returns the index of the first empty input.\n   */\n  getTabbableIndex() {\n    const {\n      length\n    } = this;\n    const firstEmptyIndex = this.getFirstEmptyIndex();\n    return firstEmptyIndex === -1 ? length - 1 : firstEmptyIndex;\n  }\n  /**\n   * Updates the tabIndexes for the input boxes.\n   * This is used to ensure that the correct input is\n   * focused when the user navigates using the tab key.\n   */\n  updateTabIndexes() {\n    const {\n      inputRefs,\n      inputValues,\n      length\n    } = this;\n    // Find first empty index after any filled boxes\n    let firstEmptyIndex = -1;\n    for (let i = 0; i < length; i++) {\n      if (!inputValues[i] || inputValues[i] === '') {\n        firstEmptyIndex = i;\n        break;\n      }\n    }\n    // Update tabIndex and aria-hidden for all inputs\n    inputRefs.forEach((input, index) => {\n      const shouldBeTabbable = firstEmptyIndex === -1 ? index === length - 1 : firstEmptyIndex === index;\n      input.tabIndex = shouldBeTabbable ? 0 : -1;\n      // If the input is empty and not the first empty input,\n      // it should be hidden from screen readers.\n      const isEmpty = !inputValues[index] || inputValues[index] === '';\n      input.setAttribute('aria-hidden', isEmpty && !shouldBeTabbable ? 'true' : 'false');\n    });\n  }\n  /**\n   * Determines if a separator should be shown for a given index by\n   * checking if the index is included in the parsed separators array.\n   */\n  showSeparator(index) {\n    const {\n      length\n    } = this;\n    return this.parsedSeparators.includes(index + 1) && index < length - 1;\n  }\n  render() {\n    var _a, _b;\n    const {\n      autocapitalize,\n      color,\n      disabled,\n      el,\n      fill,\n      hasFocus,\n      inheritedAttributes,\n      inputId,\n      inputRefs,\n      inputValues,\n      length,\n      readonly,\n      shape,\n      size\n    } = this;\n    const mode = getIonMode(this);\n    const inputmode = this.getInputmode();\n    const tabbableIndex = this.getTabbableIndex();\n    const pattern = this.getPattern();\n    const hasDescription = ((_b = (_a = el.querySelector('.input-otp-description')) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim()) !== '';\n    return h(Host, {\n      key: 'f15a29fb17b681ef55885ca36d3d5f899cbaca83',\n      class: createColorClasses(color, {\n        [mode]: true,\n        'has-focus': hasFocus,\n        [`input-otp-size-${size}`]: true,\n        [`input-otp-shape-${shape}`]: true,\n        [`input-otp-fill-${fill}`]: true,\n        'input-otp-disabled': disabled,\n        'input-otp-readonly': readonly\n      })\n    }, h(\"div\", Object.assign({\n      key: 'd7e1d4edd8aafcf2ed4313301287282e90fc7e82',\n      role: \"group\",\n      \"aria-label\": \"One-time password input\",\n      class: \"input-otp-group\"\n    }, inheritedAttributes), Array.from({\n      length\n    }).map((_, index) => h(Fragment, null, h(\"div\", {\n      class: \"native-wrapper\"\n    }, h(\"input\", {\n      class: \"native-input\",\n      id: `${inputId}-${index}`,\n      \"aria-label\": `Input ${index + 1} of ${length}`,\n      type: \"text\",\n      autoCapitalize: autocapitalize,\n      inputmode: inputmode,\n      pattern: pattern,\n      disabled: disabled,\n      readOnly: readonly,\n      tabIndex: index === tabbableIndex ? 0 : -1,\n      value: inputValues[index] || '',\n      autocomplete: \"one-time-code\",\n      ref: el => inputRefs[index] = el,\n      onInput: this.onInput(index),\n      onBlur: this.onBlur,\n      onFocus: this.onFocus(index),\n      onKeyDown: this.onKeyDown(index),\n      onPaste: this.onPaste\n    })), this.showSeparator(index) && h(\"div\", {\n      class: \"input-otp-separator\"\n    })))), h(\"div\", {\n      key: '3724a3159d02860971879a906092f9965f5a7c47',\n      class: {\n        'input-otp-description': true,\n        'input-otp-description-hidden': !hasDescription\n      }\n    }, h(\"slot\", {\n      key: '11baa2624926a08274508afe0833d9237a8dc35c'\n    })));\n  }\n  get el() {\n    return getElement(this);\n  }\n  static get watchers() {\n    return {\n      \"value\": [\"valueChanged\"],\n      \"separators\": [\"processSeparators\"],\n      \"length\": [\"processSeparators\"]\n    };\n  }\n};\nlet inputIds = 0;\nInputOTP.style = {\n  ios: inputOtpIosCss,\n  md: inputOtpMdCss\n};\nexport { InputOTP as ion_input_otp };"],"mappings":"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","names":["inputOtpIosCss","inputOtpMdCss","InputOTP","hostRef","registerInstance","createEvent","inputIds","index","event","_a","inputRefs","finalIndex","targetIndex","input","i","relatedTarget","length","rtl","isRTL","metaShortcuts","isLeft","_b","validKeyPattern","value","previousValue","validChars","char","nextIndex","isAllSelected","isEmpty","hasAvailableBoxAtEnd","newChar","c","newCharIndex","pastedText","nextEmptyIndex","__async","validIndex","tabbableIndex","separators","printIonWarning","separatorValues","_","pos","invalidSeparators","inheritAriaAttributes","pattern","type","inputmode","inputValues","newValue","currentIndex","firstEmptyIndex","shouldBeTabbable","autocapitalize","color","disabled","el","fill","hasFocus","inheritedAttributes","inputId","readonly","shape","size","mode","getIonMode","hasDescription","h","Host","createColorClasses","Fragment","getElement"],"x_google_ignoreList":[0]}